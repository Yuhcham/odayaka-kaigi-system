<!--
ネガティブワードを拾って猫を表示（ファイル）

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - Integration</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 600px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        input[type="file"] { margin: 20px 0; }
        button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; }
        button:hover { background-color: #0056b3; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; }
    </style>
</head>
<body>

    <div class="container">
        <h1>穏やか会議システム - 統合プロトタイプ</h1>
        
        <p>分析したい音声ファイル（wav, mp3など）を選んでください。</p>
        <input type="file" id="audioFile" accept="audio/*">
        <br>
        <button onclick="analyzeAudio()">AIで分析する</button>

        <div id="result">ここに分析結果が表示されます</div>
        
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
    </div>

    <script>
        // 「AIで分析する」ボタンが押されたときに実行される
        async function analyzeAudio() {
            const audioFileInput = document.getElementById('audioFile');
            const catImage = document.getElementById('catImage');
            const resultDiv = document.getElementById('result');

            // ファイルが選択されていなければ何もしない
            if (audioFileInput.files.length === 0) {
                resultDiv.textContent = 'まず音声ファイルを選択してください。';
                return;
            }

            const audioFile = audioFileInput.files[0];
            const formData = new FormData();
            formData.append('audio', audioFile);

            resultDiv.textContent = '分析中...';
            catImage.style.display = 'none'; // 分析中は猫を隠す

            try {
                // 神経を繋ぐ部分！JavaScriptがPythonサーバー(/analyze)にファイルを送信
                const response = await fetch('/analyze', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                    return;
                }

                // AIからの返事に応じて、身体（Webページ）が反応する
                resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                if (data.is_negative) {
                    catImage.style.display = 'block'; // ネガティブなら猫を表示
                }

            } catch (error) {
                resultDiv.textContent = `通信エラーが発生しました: ${error}`;
            }
        }
    </script>

</body>
</html>

-->

<!--
リアルタイム音声を拾う（拾ったかどうかがわからない）
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - Real-time</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 600px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
    </style>
</head>
<body>

    <div class="container">
        <h1>穏やか会議システム - リアルタイム版</h1>
        
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">マイクON</button>
            <button id="stopButton" onclick="stopMicrophone()">マイクOFF</button>
        </div>

        <div id="status">マイクの状態: OFF</div>
        
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
    </div>

    <script>
        // グローバル変数（マイクのストリームを保持するため）
        let mediaStream = null;

        // 「マイクON」ボタンが押されたときに実行
        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            
            try {
                // ブラウザにマイクの使用許可を求める
                // これがリアルタイム化の心臓部です
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                statusDiv.textContent = 'マイクの状態: ON (あなたの声を待っています)';
                statusDiv.style.color = 'green';
                console.log("マイクの準備ができました");

                // (ここに、音声をサーバーに送る処理を後で追加します)

            } catch (err) {
                statusDiv.textContent = 'エラー: マイクへのアクセスが拒否されました。';
                statusDiv.style.color = 'red';
                console.error("マイクへのアクセスエラー:", err);
            }
        }

        // 「マイクOFF」ボタンが押されたときに実行
        function stopMicrophone() {
            const statusDiv = document.getElementById('status');
            
            if (mediaStream) {
                // マイクのトラックをすべて停止して、アクセスを解放する
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
                statusDiv.textContent = 'マイクの状態: OFF';
                statusDiv.style.color = 'black';
                console.log("マイクを停止しました");
            }
        }
    </script>

</body>
</html>
-->

<!--

これはマイクの音量に応じてバーが変化するように変更したもの
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - Real-time</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 600px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        
        /* 音声レベルメーターのためのスタイルを追加 */
        #visualizer-container {
            width: 80%;
            height: 50px;
            margin: 20px auto;
            border: 1px solid #ccc;
            background-color: #eee;
            position: relative;
        }
        #level-bar {
            width: 0%; /* 初期値は0 */
            height: 100%;
            background-color: #28a745;
            transition: width 0.05s; /* ぬるぬる動くように */
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>穏やか会議システム - リアルタイム版</h1>
        
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">マイクON</button>
            <button id="stopButton" onclick="stopMicrophone()">マイクOFF</button>
        </div>

        <div id="status">マイクの状態: OFF</div>
        
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>

        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
    </div>

    <script>
        let mediaStream = null;
        // 音声分析のためのグローバル変数を追加
        let audioContext = null;
        let analyser = null;
        let visualizerFrameId = null;

        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                statusDiv.textContent = 'マイクの状態: ON (話してみてください！)';
                statusDiv.style.color = 'green';
                console.log("マイクの準備ができました");

                // --- 音声視覚化の処理を追加 ---
                visualizeAudio();

            } catch (err) {
                statusDiv.textContent = 'エラー: マイクへのアクセスが拒否されました。';
                statusDiv.style.color = 'red';
                console.error("マイクへのアクセスエラー:", err);
            }
        }

        function stopMicrophone() {
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
                
                // 視覚化を停止
                if (visualizerFrameId) {
                    cancelAnimationFrame(visualizerFrameId);
                }
                if (audioContext) {
                    audioContext.close();
                }
                levelBar.style.width = '0%'; // バーをリセット
                
                statusDiv.textContent = 'マイクの状態: OFF';
                statusDiv.style.color = 'black';
                console.log("マイクを停止しました");
            }
        }

        // --- 音声視覚化のための新しい関数 ---
        function visualizeAudio() {
            // AudioContextを作成（ブラウザで音を扱うためのお約束）
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            // AnalyserNodeを作成（音のデータを分析する道具）
            analyser = audioContext.createAnalyser();
            // マイクの音源をAnalyserに接続
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);

            // 分析の細かさを設定
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');

            // 描画ループを開始
            function draw() {
                // 繰り返し描画を予約
                visualizerFrameId = requestAnimationFrame(draw);
                
                // 現在の音の大きさを取得
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                
                // 平均音量をバーの幅に変換（0-100%）
                const level = (average / 128) * 100;
                levelBar.style.width = level + '%';
            }
            
            draw();
        }
    </script>

</body>
</html>

-->

<!--
一回目の音声分析は成功したが、２回目からエラー
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - Real-time</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 600px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - リアルタイム版</h1>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">マイクON</button>
            <button id="stopButton" onclick="stopMicrophone()">マイクOFF</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
    </div>

    <script>
        let mediaStream = null;
        let audioContext = null;
        let analyser = null;
        let visualizerFrameId = null;
        // --- 録音機能を管理するための新しい変数を追加 ---
        let mediaRecorder = null;

        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            if (mediaStream) return; // すでにONなら何もしない
            
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                statusDiv.textContent = 'マイクの状態: ON (5秒ごとに分析します)';
                statusDiv.style.color = 'green';
                visualizeAudio();

                // --- ここからがリアルタイム分析のキモ！ ---
                mediaRecorder = new MediaRecorder(mediaStream);

                // 5秒ごとに録音が完了すると、この部分が自動的に実行される
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0) {
                        console.log("5秒分の音声を録音しました。サーバーに送信します...");
                        const audioBlob = event.data;
                        const formData = new FormData();
                        // 録音データを 'audio' という名前で添付
                        formData.append('audio', audioBlob, 'realtime_audio.webm');

                        // 以前と同じように、サーバーに送信
                        const resultDiv = document.getElementById('result');
                        resultDiv.textContent = '分析中...';
                        try {
                            const response = await fetch('/analyze', { method: 'POST', body: formData });
                            const data = await response.json();
                            if (data.error) {
                                resultDiv.textContent = `エラー: ${data.error}`;
                            } else {
                                resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                                if (data.is_negative) {
                                    document.getElementById('catImage').style.display = 'block';
                                } else {
                                    document.getElementById('catImage').style.display = 'none';
                                }
                            }
                        } catch (err) {
                            resultDiv.textContent = `通信エラー: ${err}`;
                        }
                    }
                };

                // 5000ミリ秒（5秒）ごとに区切って録音を開始
                mediaRecorder.start(5000);

            } catch (err) {
                // ... (エラー処理は省略)
            }
        }

        function stopMicrophone() {
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop(); // 録音を停止
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (visualizerFrameId) {
                cancelAnimationFrame(visualizerFrameId);
            }
            if (audioContext) {
                audioContext.close();
            }
            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }

        // --- 音声視覚化の関数（変更なし） ---
        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                levelBar.style.width = (average / 128) * 100 + '%';
            }
            draw();
        }
    </script>
</body>
</html>

-->

<!--
分析には成功したが、なぜか無音の状態でもAIが変に解釈して決まった言葉ばかり出てきてしまう
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - Real-time</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 600px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - リアルタイム版</h1>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">マイクON</button>
            <button id="stopButton" onclick="stopMicrophone()">マイクOFF</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
    </div>

    <script>
        let mediaStream = null;
        let audioContext = null;
        let analyser = null;
        let visualizerFrameId = null;
        let recordingInterval = null;

        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                statusDiv.textContent = 'マイクの状態: ON (リアルタイム分析中)';
                statusDiv.style.color = 'green';
                visualizeAudio();
                
                recordingInterval = setInterval(recordAndSend, 5000);

            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }

        function stopMicrophone() {
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (visualizerFrameId) {
                cancelAnimationFrame(visualizerFrameId);
            }
            if (audioContext) {
                audioContext.close();
            }
            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }

        async function recordAndSend() {
            if (!mediaStream) return;

            const recorder = new MediaRecorder(mediaStream);
            const audioChunks = [];

            recorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            recorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const formData = new FormData();
                formData.append('audio', audioBlob, 'realtime_audio.webm');

                const resultDiv = document.getElementById('result');
                resultDiv.textContent = '分析中...';
                try {
                    const response = await fetch('/analyze', { method: 'POST', body: formData });
                    const data = await response.json();
                    if (data.error) {
                        resultDiv.textContent = `エラー: ${data.error}`;
                    } else {
                        resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                        if (data.is_negative) {
                            document.getElementById('catImage').style.display = 'block';
                        } else {
                            document.getElementById('catImage').style.display = 'none';
                        }
                    }
                } catch (err) {
                    resultDiv.textContent = `通信エラー: ${err}`;
                }
            };
            
            recorder.start();
            
            setTimeout(() => {
                if (recorder.state === 'recording') {
                    recorder.stop();
                }
            }, 4900);
        }

        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                levelBar.style.width = (average / 128) * 100 + '%';
            }
            draw();
        }
    </script>
</body>
</html>
-->
<!--
このプログラムは５秒ごとに正確にマイクの発言を拾って出力してくれるが、次々と更新されるので記録ができない。
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - Real-time</title>
    <style>
        /* style部分は変更ありません */
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 600px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Confy "コンフィー"</h1>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">マイクON</button>
            <button id="stopButton" onclick="stopMicrophone()">マイクOFF</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
    </div>

    <script>
        let mediaStream = null;
        let audioContext = null;
        let analyser = null;
        let visualizerFrameId = null;
        let recordingInterval = null;
        // --- 現在の音量を保持する変数を追加 ---
        let currentVolume = 0;

        async function startMicrophone() {
            // ... (この関数の中身は変更ありません)
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                statusDiv.textContent = 'マイクの状態: ON (リアルタイム分析中)';
                statusDiv.style.color = 'green';
                visualizeAudio();
                recordingInterval = setInterval(recordAndSend, 5000);
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }

        function stopMicrophone() {
            // ... (この関数の中身は変更ありません)
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (visualizerFrameId) {
                cancelAnimationFrame(visualizerFrameId);
            }
            if (audioContext) {
                audioContext.close();
            }
            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }

        async function recordAndSend() {
            const resultDiv = document.getElementById('result');
            // --- 無音検知のロジックを追加 ---
            // 音量が一定のしきい値（ここでは5）より小さい場合は、処理を中断
            //無音の閾値はおおよそ0.25くらいであると推定
            if (currentVolume < 0.25) {
                resultDiv.textContent = '無音のため分析をスキップしました。';
                console.log("Skipping analysis due to silence.");
                return; // ここで関数を終了させる
            }

            if (!mediaStream) return;
            const recorder = new MediaRecorder(mediaStream);
            const audioChunks = [];
            recorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };
            recorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const formData = new FormData();
                formData.append('audio', audioBlob, 'realtime_audio.webm');
                resultDiv.textContent = '分析中...';
                try {
                    const response = await fetch('/analyze', { method: 'POST', body: formData });
                    const data = await response.json();
                    if (data.error) {
                        resultDiv.textContent = `エラー: ${data.error}`;
                    } else {
                        resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                        if (data.is_negative) {
                            document.getElementById('catImage').style.display = 'block';
                        } else {
                            document.getElementById('catImage').style.display = 'none';
                        }
                    }
                } catch (err) {
                    resultDiv.textContent = `通信エラー: ${err}`;
                }
            };
            recorder.start();
            setTimeout(() => {
                if (recorder.state === 'recording') {
                    recorder.stop();
                }
            }, 4900);
        }

        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                
                // --- 現在の音量をグローバル変数に保存する処理を追加 ---
                currentVolume = average;

                levelBar.style.width = (average / 128) * 100 + '%';
            }
            draw();
        }
    </script>
</body>
</html>

-->
<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - with Minutes</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #downloadButton { background-color: #17a2b8; color: white; display: none; /* 最初は非表示 */ }
        #downloadButton:hover { background-color: #138496; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        /* --- 議事録エリアのスタイルを追加 --- */
        #minutes-container {
            margin-top: 30px;
            text-align: left;
            border-top: 2px solid #ddd;
            padding-top: 15px;
        }
        #minutes-container h2 { text-align: center; }
        #minutes-log {
            height: 200px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #fafafa;
            white-space: pre-wrap; /* 改行をそのまま表示 */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - 議事録機能付き</h1>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始 start</button>
            <button id="stopButton" onclick="stopMicrophone()">終了 finish</button>
        </div>

        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">

        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="downloadButton" onclick="downloadMinutes()">議事録をダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        // ... (上部の変数の定義は変更なし)
        let mediaStream = null;
        let audioContext = null;
        let analyser = null;
        let visualizerFrameId = null;
        let recordingInterval = null;
        let currentVolume = 0;
        // --- 議事録の全文を保存する変数を追加 ---
        let fullTranscript = "";

        async function startMicrophone() {
            // ... (この関数の中身はほぼ変更なし)
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;

            // --- 議事録とダウンロードボタンをリセットする処理を追加 ---
            fullTranscript = ""; // 議事録を初期化
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                statusDiv.textContent = 'マイクの状態: ON (リアルタイム分析中)';
                statusDiv.style.color = 'green';
                visualizeAudio();
                recordingInterval = setInterval(recordAndSend, 5000);
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }

        function stopMicrophone() {
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            
            // --- ダウンロードボタンを表示する処理を追加 ---
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
            }
            
            // ... (残りの部分は変更なし)
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (visualizerFrameId) {
                cancelAnimationFrame(visualizerFrameId);
            }
            if (audioContext) {
                audioContext.close();
            }
            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }

        async function recordAndSend() {
            // ... (この関数はほぼ変更なし)
            const resultDiv = document.getElementById('result');
            if (currentVolume < 0.00001) {
                resultDiv.textContent = '無音のため分析をスキップしました。';
                return;
            }
            if (!mediaStream) return;
            const recorder = new MediaRecorder(mediaStream);
            const audioChunks = [];
            recorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };
            recorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const formData = new FormData();
                formData.append('audio', audioBlob, 'realtime_audio.webm');
                resultDiv.textContent = '分析中...';
                try {
                    const response = await fetch('/analyze', { method: 'POST', body: formData });
                    const data = await response.json();
                    if (data.error) {
                        resultDiv.textContent = `エラー: ${data.error}`;
                    } else {
                        resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                        // --- 議事録に追加する処理 ---
                        if (data.text && data.text.trim().length > 0) {
                            const timestamp = new Date().toLocaleTimeString('ja-JP');
                            const logEntry = `[${timestamp}] ${data.text}\n`;
                            fullTranscript += logEntry; // 全文変数に保存
                            document.getElementById('minutes-log').textContent = fullTranscript; // 画面に表示
                            // 自動で一番下までスクロール
                            const minutesLog = document.getElementById('minutes-log');
                            minutesLog.scrollTop = minutesLog.scrollHeight;
                        }

                        if (data.is_negative) {
                            document.getElementById('catImage').style.display = 'block';
                        } else {
                            document.getElementById('catImage').style.display = 'none';
                        }
                    }
                } catch (err) {
                    resultDiv.textContent = `通信エラー: ${err}`;
                }
            };
            recorder.start();
            setTimeout(() => {
                if (recorder.state === 'recording') {
                    recorder.stop();
                }
            }, 4900);
        }

        // --- 議事録ダウンロードのための新しい関数を追加 ---
        function downloadMinutes() {
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '議事録.txt'; // ダウンロードするファイル名
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function visualizeAudio() {
            // ... (この関数は変更ありません)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                currentVolume = average;
                levelBar.style.width = (average / 128) * 100 + '%';
            }
            draw();
        }
    </script>
</body>
</html>
-->

<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - with Minutes</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #downloadButton { background-color: #17a2b8; color: white; display: none; }
        #downloadButton:hover { background-color: #138496; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        #minutes-container { margin-top: 30px; text-align: left; border-top: 2px solid #ddd; padding-top: 15px; }
        #minutes-container h2 { text-align: center; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background-color: #fafafa; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - 議事録機能付き</h1>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始 start</button>
            <button id="stopButton" onclick="stopMicrophone()">終了 finish</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="downloadButton" onclick="downloadMinutes()">議事録をダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        // --- 変数定義 (変更なし) ---
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, recordingInterval = null, currentVolume = 0, fullTranscript = "";

        async function startMicrophone() {
            // ... (この関数の中身はほぼ変更なし)
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                statusDiv.textContent = 'マイクの状態: ON (リアルタイム分析中)';
                statusDiv.style.color = 'green';
                visualizeAudio();
                console.log("【デバッグ】: 5秒ごとのインターバルを開始します。");
                recordingInterval = setInterval(recordAndSend, 5000);
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }

        function stopMicrophone() {
            // ... (この関数の中身はほぼ変更なし)
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
            }
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
                console.log("【デバッグ】: インターバルを停止しました。");
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext) audioContext.close();
            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }

        async function recordAndSend() {
            console.log(`【デバッグ】: recordAndSendが呼ばれました。現在の音量: ${currentVolume}`);
            const resultDiv = document.getElementById('result');
            
            // --- 無音検知のしきい値を現実的な値に戻しました ---
            if (currentVolume < 5) {
                resultDiv.textContent = '無音のため分析をスキップしました。';
                console.log("【デバッグ】: 無音と判断し、処理をスキップします。");
                return;
            }

            if (!mediaStream) return;
            console.log("【デバッグ】: MediaRecorderの作成を開始します。");
            const recorder = new MediaRecorder(mediaStream);
            const audioChunks = [];

            recorder.ondataavailable = event => {
                console.log("【デバッグ】: ondataavailableイベントが発生しました。");
                audioChunks.push(event.data);
            };

            recorder.onstop = async () => {
                console.log("【デバッグ】: onstopイベントが発生しました。サーバーに送信します。");
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const formData = new FormData();
                formData.append('audio', audioBlob, 'realtime_audio.webm');
                resultDiv.textContent = '分析中...';
                try {
                    const response = await fetch('/analyze', { method: 'POST', body: formData });
                    const data = await response.json();
                    console.log("【デバッグ】: サーバーからの応答:", data);
                    if (data.error) {
                        resultDiv.textContent = `エラー: ${data.error}`;
                    } else {
                        resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                        if (data.text && data.text.trim().length > 0) {
                            const timestamp = new Date().toLocaleTimeString('ja-JP');
                            const logEntry = `[${timestamp}] ${data.text}\n`;
                            fullTranscript += logEntry;
                            const minutesLog = document.getElementById('minutes-log');
                            minutesLog.textContent = fullTranscript;
                            minutesLog.scrollTop = minutesLog.scrollHeight;
                        }
                        if (data.is_negative) {
                            document.getElementById('catImage').style.display = 'block';
                        } else {
                            document.getElementById('catImage').style.display = 'none';
                        }
                    }
                } catch (err) {
                    resultDiv.textContent = `通信エラー: ${err}`;
                    console.error("【デバッグ】: 通信エラー:", err);
                }
            };
            
            recorder.start();
            console.log("【デバッグ】: 録音を開始しました。4.9秒後に停止します。");
            setTimeout(() => {
                if (recorder.state === 'recording') {
                    recorder.stop();
                }
            }, 4900);
        }

        function downloadMinutes() {
            // ... (この関数は変更なし)
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '議事録.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function visualizeAudio() {
            // ... (この関数は変更なし)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                currentVolume = average;
                levelBar.style.width = (average / 128) * 100 + '%';
            }
            draw();
        }
    </script>
</body>
</html>
-->

<!--
区間録音になっているが次は部分録音へ改造
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - with Minutes</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #downloadButton { background-color: #17a2b8; color: white; display: none; }
        #downloadButton:hover { background-color: #138496; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        #minutes-container { margin-top: 30px; text-align: left; border-top: 2px solid #ddd; padding-top: 15px; }
        #minutes-container h2 { text-align: center; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background-color: #fafafa; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - 議事録機能付き</h1>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始 start</button>
            <button id="stopButton" onclick="stopMicrophone()">終了 finish</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="downloadButton" onclick="downloadMinutes()">議事録をダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, recordingInterval = null, currentVolume = 0, fullTranscript = "";

        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            try {
                // --- 改善策①: ブラウザ側でのノイズ抑制を明示 ---
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                statusDiv.textContent = 'マイクの状態: ON (リアルタイム分析中)';
                statusDiv.style.color = 'green';
                visualizeAudio();
                recordingInterval = setInterval(recordAndSend, 2000);
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }

        // --- 改善策②: stopMicrophoneをasync関数に変更し、完全なリセット処理を追加 ---
        async function stopMicrophone() {
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
            }
            
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (visualizerFrameId) {
                cancelAnimationFrame(visualizerFrameId);
                visualizerFrameId = null; // ★完全にリセット
            }
            if (audioContext && audioContext.state !== 'closed') {
                await audioContext.close(); // ★完全に閉じるのを待つ
                audioContext = null; // ★完全にリセット
            }
            analyser = null; // ★完全にリセット

            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }

        // --- 以下の関数は変更ありません ---
        async function recordAndSend() {
            const resultDiv = document.getElementById('result');
            if (currentVolume < 3) {
                resultDiv.textContent = '無音のため分析をスキップしました。';
                return;
            }
            if (!mediaStream) return;
            const recorder = new MediaRecorder(mediaStream);
            const audioChunks = [];
            recorder.ondataavailable = event => { audioChunks.push(event.data); };
            recorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const formData = new FormData();
                formData.append('audio', audioBlob, 'realtime_audio.webm');
                resultDiv.textContent = '分析中...';
                try {
                    const response = await fetch('/analyze', { method: 'POST', body: formData });
                    const data = await response.json();
                    if (data.error) {
                        resultDiv.textContent = `エラー: ${data.error}`;
                    } else {
                        resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                        if (data.text && data.text.trim().length > 0) {
                            const timestamp = new Date().toLocaleTimeString('ja-JP');
                            const logEntry = `[${timestamp}] ${data.text}\n`;
                            fullTranscript += logEntry;
                            const minutesLog = document.getElementById('minutes-log');
                            minutesLog.textContent = fullTranscript;
                            minutesLog.scrollTop = minutesLog.scrollHeight;
                        }
                        if (data.is_negative) {
                            document.getElementById('catImage').style.display = 'block';
                        } else {
                            document.getElementById('catImage').style.display = 'none';
                        }
                    }
                } catch (err) {
                    resultDiv.textContent = `通信エラー: ${err}`;
                }
            };
            recorder.start();
            setTimeout(() => {
                if (recorder.state === 'recording') {
                    recorder.stop();
                }
            }, 1900);
        }

        function downloadMinutes() {
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '議事録.txt';
            document.body.appendChild(a);
a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                currentVolume = average;
                levelBar.style.width = (average / 128) * 100 + '%';
            }
            draw();
        }
    </script>
</body>
</html>

-->

<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - VAD</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #downloadButton { background-color: #17a2b8; color: white; display: none; }
        #downloadButton:hover { background-color: #138496; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        #minutes-container { margin-top: 30px; text-align: left; border-top: 2px solid #ddd; padding-top: 15px; }
        #minutes-container h2 { text-align: center; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background-color: #fafafa; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - VAD機能付き</h1>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始 start</button>
            <button id="stopButton" onclick="stopMicrophone()">終了 finish</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="downloadButton" onclick="downloadMinutes()">議事録をダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        // --- VADのための設定値を追加 ---
        const SPEAKING_THRESHOLD = 15; // これ以上の音量なら「話している」と判断
        const SILENCE_DELAY = 1000;   // 1.5秒黙ったら「発言終了」と判断

        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        // --- VADのための状態管理変数を追加 ---
        let mediaRecorder = null;
        let isRecording = false;
        let silenceTimer = null;

        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = 'green';
                visualizeAudio(); // 音量監視を開始
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }

        async function stopMicrophone() {
            if (isRecording) { // もし録音中なら、強制的に送信
                mediaRecorder.stop();
            }
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;

            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }
        
        // 音声視覚化とVADの司令塔
        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');

            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                levelBar.style.width = (average / 128) * 100 + '%';

                // --- ここからがVADのロジック ---
                if (average > SPEAKING_THRESHOLD) { // 話し始めた、または話している途中
                    if (!isRecording) {
                        startRecording();
                    }
                    if (silenceTimer) {
                        clearTimeout(silenceTimer);
                        silenceTimer = null;
                    }
                } else { // 静かになった
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => {
                            stopRecordingAndSend();
                        }, SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            console.log("録音開始");

            const audioChunks = [];
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                sendToServer(audioBlob);
            };
        }

        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
                console.log("録音停止、サーバーへ送信");
            }
        }

        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '分析中...';
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                } else {
                    resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                    if (data.text && data.text.trim().length > 0) {
                        const timestamp = new Date().toLocaleTimeString('ja-JP');
                        const logEntry = `[${timestamp}] ${data.text}\n`;
                        fullTranscript += logEntry;
                        const minutesLog = document.getElementById('minutes-log');
                        minutesLog.textContent = fullTranscript;
                        minutesLog.scrollTop = minutesLog.scrollHeight;
                    }
                    if (data.is_negative) {
                        document.getElementById('catImage').style.display = 'block';
                    } else {
                        document.getElementById('catImage').style.display = 'none';
                    }
                }
            } catch (err) {
                resultDiv.textContent = `通信エラー: ${err}`;
            }
        }
        
        function downloadMinutes() {
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '議事録.txt'; // ダウンロードするファイル名
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>

-->


<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - with Title</title>
    <style>
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        /* --- 会議タイトル入力欄のスタイルを追加 --- */
        #title-container { margin-bottom: 20px; }
        #meeting-title { width: 80%; padding: 10px; font-size: 1.1em; border: 1px solid #ccc; border-radius: 5px; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton { background-color: #28a745; color: white; }
        #startButton:hover { background-color: #218838; }
        #stopButton { background-color: #dc3545; color: white; }
        #stopButton:hover { background-color: #c82333; }
        #downloadButton { background-color: #17a2b8; color: white; display: none; }
        #downloadButton:hover { background-color: #138496; }
        #status { margin: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; background-color: #eee; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { margin-top: 20px; font-size: 1.1em; color: #555; min-height: 2em; }
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        #minutes-container { margin-top: 30px; text-align: left; border-top: 2px solid #ddd; padding-top: 15px; }
        #minutes-container h2 { text-align: center; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background-color: #fafafa; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - VAD機能付き</h1>
        
        <div id="title-container">
            <input type="text" id="meeting-title" placeholder="会議のタイトルを入力してください">
        </div>

        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始 start</button>
            <button id="stopButton" onclick="stopMicrophone()">終了 finish</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container">
            <div id="level-bar"></div>
        </div>
        <div id="result">ここに分析結果が表示されます</div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="downloadButton" onclick="downloadMinutes()">議事録をダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        const SPEAKING_THRESHOLD = 10;
        const SILENCE_DELAY = 1000;
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null;

        async function startMicrophone() {
            // ... (この関数は変更なし)
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = 'green';
                visualizeAudio();
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }

        async function stopMicrophone() {
            // ... (この関数は変更なし)
            if (isRecording) {
                mediaRecorder.stop();
            }
            const statusDiv = document.getElementById('status');
            const levelBar = document.getElementById('level-bar');
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            levelBar.style.width = '0%';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
        }
        
        function visualizeAudio() {
            // ... (この関数は変更なし)
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const levelBar = document.getElementById('level-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                levelBar.style.width = (average / 128) * 100 + '%';
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) { startRecording(); }
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => { stopRecordingAndSend(); }, SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        function startRecording() {
            // ... (この関数は変更なし)
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => { audioChunks.push(event.data); };
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                sendToServer(audioBlob);
            };
        }

        function stopRecordingAndSend() {
            // ... (この関数は変更なし)
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }

        async function sendToServer(audioBlob) {
            // ... (この関数は変更なし)
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '分析中...';
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                } else {
                    resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                    if (data.text && data.text.trim().length > 0) {
                        const timestamp = new Date().toLocaleTimeString('ja-JP');
                        const logEntry = `[${timestamp}] ${data.text}\n`;
                        fullTranscript += logEntry;
                        const minutesLog = document.getElementById('minutes-log');
                        minutesLog.textContent = fullTranscript;
                        minutesLog.scrollTop = minutesLog.scrollHeight;
                    }
                    if (data.is_negative) {
                        document.getElementById('catImage').style.display = 'block';
                    } else {
                        document.getElementById('catImage').style.display = 'none';
                    }
                }
            } catch (err) {
                resultDiv.textContent = `通信エラー: ${err}`;
            }
        }
        
        // --- ★★★ ここに動的なファイル名生成のロジックを追加 ★★★ ---
        function downloadMinutes() {
            // 入力欄から会議タイトルを取得
            let meetingTitle = document.getElementById('meeting-title').value;
            
            // もしタイトルが空なら、デフォルトの名前を付ける
            if (meetingTitle.trim() === "") {
                meetingTitle = "議事録";
            }

            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // ここで動的にファイル名を設定！
            a.download = `${meetingTitle}.txt`; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
-->

<!--LLMを実装します！-->


<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Odayaka System - Final</title>
    <style>
        /* ... style部分は変更なし ... */
        body { font-family: sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .input-group { margin-bottom: 20px; }
        .input-group input, .input-group textarea { width: 80%; padding: 10px; font-size: 1.1em; border: 1px solid #ccc; border-radius: 5px; margin-top: 5px; }
        .input-group textarea { height: 80px; resize: vertical; }
        .controls button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; margin: 5px; }
        #startButton, #stopButton, #downloadButton, #correctButton { display: inline-block; }
        #downloadButton, #correctButton { display: none; }
        #startButton { background-color: #28a745; color: white; }
        #stopButton { background-color: #dc3545; color: white; }
        #downloadButton { background-color: #17a2b8; color: white; }
        #correctButton { background-color: #ffc107; color: black; }
        #status { margin: 20px 0; font-weight: bold; }
        #visualizer-container { width: 80%; height: 50px; margin: 20px auto; border: 1px solid #ccc; position: relative; }
        #level-bar { width: 0%; height: 100%; background-color: #28a745; transition: width 0.05s; }
        #result { font-size: 1.2em; color: #333; min-height: 1.5em; font-weight: bold; }
        /* --- ★★★ スコア表示用のスタイルを追加 ★★★ --- */
        #stats-display { font-size: 0.9em; color: #666; min-height: 1.2em; margin-top: 5px;}
        #catImage { margin-top: 20px; max-width: 400px; display: none; }
        #minutes-container { margin-top: 30px; text-align: left; border-top: 2px solid #ddd; padding-top: 15px; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background-color: #fafafa; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div class="container">
        <h1>穏やか会議システム - 最終形態</h1>
        <div class="input-group">
            <input type="text" id="meeting-title" placeholder="会議のタイトルを入力">
        </div>
        <div class="input-group">
            <textarea id="meeting-prompt" placeholder="AIへのヒント（専門用語や固有名詞など）をここに入力"></textarea>
        </div>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始</button>
            <button id="stopButton" onclick="stopMicrophone()">終了</button>
        </div>
        <div id="status">マイクの状態: OFF</div>
        <div id="visualizer-container"><div id="level-bar"></div></div>
        
        <div id="result">ここに分析結果が表示されます</div>
        <div id="stats-display">（AIの思考がここに表示されます）</div>

        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin-top:20px; max-width:400px;">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="correctButton" onclick="correctWithLLM()">LLMで校正する</button>
                <button id="downloadButton" onclick="downloadMinutes()">議事録をダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        // --- sendToServer関数を改造 ---
        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            const promptText = document.getElementById('meeting-prompt').value;
            formData.append('prompt', promptText);

            const resultDiv = document.getElementById('result');
            const statsDiv = document.getElementById('stats-display'); // ★スコア表示用の要素を取得
            resultDiv.textContent = '分析中...';
            statsDiv.textContent = '（AIが思考中...）'; // ★分析中の表示

            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                
                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                    statsDiv.textContent = '---';
                } else {
                    resultDiv.textContent = `文字起こし結果: 「${data.text}」`;
                    // ★★★ 受け取ったスコアを表示する処理を追加 ★★★
                    statsDiv.textContent = `(AIの自信: ${data.confidence}% / 無発話確率: ${data.no_speech_prob}%)`;
                    
                    if (data.text && data.text.trim().length > 0) {
                        const timestamp = new Date().toLocaleTimeString('ja-JP');
                        const logEntry = `[${timestamp}] ${data.text}\n`;
                        fullTranscript += logEntry;
                        const minutesLog = document.getElementById('minutes-log');
                        minutesLog.textContent = fullTranscript;
                        minutesLog.scrollTop = minutesLog.scrollHeight;
                    }
                    if (data.is_negative) {
                        document.getElementById('catImage').style.display = 'block';
                    } else {
                        document.getElementById('catImage').style.display = 'none';
                    }
                }
            } catch (err) {
                resultDiv.textContent = `通信エラー: ${err}`;
                statsDiv.textContent = '---';
            }
        }
        
        // --- 他のJavaScript関数は変更ありません ---
        const SPEAKING_THRESHOLD = 5, SILENCE_DELAY = 1500;
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null;
        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = 'green';
                visualizeAudio();
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = 'red';
            }
        }
        async function stopMicrophone() {
            if (isRecording) mediaRecorder.stop();
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            document.getElementById('level-bar').style.width = '0%';
            document.getElementById('status').textContent = 'マイクの状態: OFF';
            document.getElementById('status').style.color = 'black';
            document.getElementById('result').textContent = 'ここに分析結果が表示されます';
            document.getElementById('stats-display').textContent = '（AIの思考がここに表示されます）';
        }
        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                document.getElementById('level-bar').style.width = (average / 128) * 100 + '%';
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) startRecording();
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => stopRecordingAndSend(), SILENCE_DELAY);
                    }
                }
            }
            draw();
        }
        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
            mediaRecorder.onstop = () => sendToServer(new Blob(audioChunks, { type: 'audio/webm' }));
        }
        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }
        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLMが校正中です...賢くなるまでしばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }
        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-title').value;
            if (meetingTitle.trim() === "") meetingTitle = "議事録";
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
-->


<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>穏やか会議システム</title>
    <style>
        /* --- Google Fontsから美しいフォントを読み込み --- */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');

        /* --- 全体のスタイルをリニューアル --- */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            text-align: center;
            margin: 0;
            background-color: #f4f7f9; /* より柔らかい背景色 */
            color: #4A5568; /* 全体の文字色を少し柔らかく */
        }
        
        /* --- ヘッダー画像のスタイル --- */
        .header {
            width: 100%;
            height: 350px; /* 高さを出してタイトルを目立たせる */
            background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url("{{ url_for('static', filename='header.jpg') }}");
            background-size: cover;
            background-position: center;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
        }
        
        /* ★ヘッダーのメインタイトル */
        .header h1 {
            font-size: 3.5em; /* 文字を大きく */
            font-weight: 700;
            margin: 0;
            letter-spacing: 2px;
        }
        
        /* ★ヘッダーのサブタイトル */
        .header p {
            font-size: 1.2em;
            font-weight: 400;
            margin-top: 10px;
            opacity: 0.9;
        }

        .container {
            max-width: 850px;
            margin: 40px auto 50px auto; 
            background: white;
            padding: 30px 50px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
            text-align: left; /* コンテナ内は左揃えを基本に */
        }
        
        h2 {
            font-size: 1.5em;
            color: #2D3748;
            border-bottom: 2px solid #E2E8F0;
            padding-bottom: 10px;
            margin-bottom: 25px;
            text-align: center;
        }

        .input-group {
            margin-bottom: 25px;
        }
        .input-group label {
            display: block;
            text-align: left;
            font-weight: 500;
            margin-bottom: 8px;
            color: #4A5568;
        }
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 12px 15px;
            font-size: 1em;
            border: 1px solid #CBD5E0;
            border-radius: 8px;
            box-sizing: border-box;
            transition: all 0.3s;
        }
        .input-group input:focus, .input-group textarea:focus {
            border-color: #4299E1;
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.2);
            outline: none;
        }
        .input-group textarea {
            height: 80px;
            resize: vertical;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px; /* ボタン間のスペース */
            margin: 30px 0;
        }
        .controls button {
            font-size: 1.1em;
            font-weight: bold;
            padding: 12px 30px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: all 0.2s;
        }
        .controls button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        #startButton { background-color: #4299E1; color: white; }
        #stopButton { background-color: #F56565; color: white; }
        
        .result-area {
            background-color: #F7FAFC;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }
        #status { font-weight: bold; font-size: 1.1em; margin-bottom: 20px; }
        #visualizer-container { width: 100%; height: 8px; border-radius: 4px; position: relative; overflow: hidden; background-color: #E2E8F0; }
        #level-bar { width: 0%; height: 100%; background-color: #48BB78; transition: width 0.05s; }
        #result { font-size: 1.1em; color: #2D3748; min-height: 1.5em; font-weight: 500; margin-top: 20px; }
        #stats-display { font-size: 0.9em; color: #A0AEC0; min-height: 1.2em; margin-top: 8px; }
        
        .minutes-actions { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .minutes-actions button { display: none; } /* 最初は非表示 */
        #downloadButton { background-color: #38B2AC; color: white; }
        #correctButton { background-color: #ED8936; color: white; }
    </style>
</head>
<body>
    <div class="header">
        <h1>穏やか会議システム</h1>
        <p>AIが会議の心理的安全性をサポートします</p>
    </div>

    <div class="container">
        <div class="input-group">
            <label for="meeting-title">会議タイトル</label>
            <input type="text" id="meeting-title" placeholder="例：第一回 定例会議">
        </div>
        <div class="input-group">
            <label for="meeting-prompt">AIへのヒント</label>
            <textarea id="meeting-prompt" placeholder="会議で使われる専門用語や固有名詞などを入力..."></textarea>
        </div>

        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始</button>
            <button id="stopButton" onclick="stopMicrophone()">終了</button>
        </div>
        
        <div class="result-area">
            <div id="status">マイクの状態: OFF</div>
            <div id="visualizer-container"><div id="level-bar"></div></div>
            <div id="result">ここに分析結果が表示されます</div>
            <div id="stats-display">（AIの思考がここに表示されます）</div>
        </div>

        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin-top:20px; max-width:400px;">
        
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div class="minutes-actions">
                <button id="correctButton" onclick="correctWithLLM()" class="controls-button">LLMで校正</button>
                <button id="downloadButton" onclick="downloadMinutes()" class="controls-button">ダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        // JavaScript部分は一切変更ありません
        const SPEAKING_THRESHOLD = 5, SILENCE_DELAY = 1500;
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null;
        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = '#38A169';
                visualizeAudio();
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = '#E53E3E';
            }
        }
        async function stopMicrophone() {
            if (isRecording) mediaRecorder.stop();
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            document.getElementById('level-bar').style.width = '0%';
            document.getElementById('status').textContent = 'マイクの状態: OFF';
            document.getElementById('status').style.color = 'black';
            document.getElementById('result').textContent = 'ここに分析結果が表示されます';
            document.getElementById('stats-display').textContent = '（AIの思考がここに表示されます）';
        }
        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                document.getElementById('level-bar').style.width = (average / 128) * 100 + '%';
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) startRecording();
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => stopRecordingAndSend(), SILENCE_DELAY);
                    }
                }
            }
            draw();
        }
        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
            mediaRecorder.onstop = () => sendToServer(new Blob(audioChunks, { type: 'audio/webm' }));
        }
        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }
        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            const promptText = document.getElementById('meeting-prompt').value;
            formData.append('prompt', promptText);
            const resultDiv = document.getElementById('result');
            const statsDiv = document.getElementById('stats-display');
            resultDiv.textContent = '分析中...';
            statsDiv.textContent = '（AIが思考中...）';
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                    statsDiv.textContent = '---';
                } else {
                    const filteredText = data.filtered_text;
                    const rawSegments = data.raw_segments;
                    if (rawSegments && rawSegments.length > 0) {
                        const lastSegment = rawSegments[rawSegments.length - 1];
                        resultDiv.textContent = `「${lastSegment.text}」`;
                        statsDiv.textContent = `(AIの自信: ${lastSegment.confidence}% / 無発話確率: ${lastSegment.no_speech_prob}%)`;
                    } else {
                        resultDiv.textContent = '（有効な発言なし）';
                        statsDiv.textContent = '---';
                    }
                    if (filteredText && filteredText.trim().length > 0) {
                        const timestamp = new Date().toLocaleTimeString('ja-JP');
                        const logEntry = `[${timestamp}] ${filteredText}\n`;
                        fullTranscript += logEntry;
                        const minutesLog = document.getElementById('minutes-log');
                        minutesLog.textContent = fullTranscript;
                        minutesLog.scrollTop = minutesLog.scrollHeight;
                    }
                    if (data.is_negative) {
                        document.getElementById('catImage').style.display = 'block';
                    } else {
                        document.getElementById('catImage').style.display = 'none';
                    }
                }
            } catch (err) {
                resultDiv.textContent = `通信エラー: ${err}`;
                statsDiv.textContent = '---';
            }
        }
        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLMが校正中です...しばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }
        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-title').value;
            if (meetingTitle.trim() === "") meetingTitle = "議事録";
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>

-->

<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>穏やか会議システム</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');

        body {
            font-family: 'Noto Sans JP', sans-serif;
            text-align: center;
            margin: 0;
            background-color: #f4f7f9;
            color: #4A5568;
        }
        
        .header {
            width: 100%;
            height: 250px;
            background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url("{{ url_for('static', filename='header.jpg') }}");
            background-size: cover;
            background-position: center;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
        }
        
        .header h1 {
            font-size: 3.5em;
            font-weight: 700;
            margin: 0;
            letter-spacing: 2px;
        }
        
        .header p {
            font-size: 1.2em;
            font-weight: 400;
            margin-top: 10px;
            opacity: 0.9;
        }

        .container {
            max-width: 850px;
            margin: 40px auto 50px auto; 
            background: white;
            padding: 30px 50px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
            text-align: left;
        }
        
        h2 {
            font-size: 1.5em;
            color: #2D3748;
            border-bottom: 2px solid #E2E8F0;
            padding-bottom: 10px;
            margin-bottom: 25px;
            text-align: center;
        }

        .input-group {
            margin-bottom: 25px;
        }
        .input-group label {
            display: block;
            text-align: left;
            font-weight: 500;
            margin-bottom: 8px;
            color: #4A5568;
        }
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 12px 15px;
            font-size: 1em;
            border: 1px solid #CBD5E0;
            border-radius: 8px;
            box-sizing: border-box;
            transition: all 0.3s;
        }
        .input-group input:focus, .input-group textarea:focus {
            border-color: #4299E1;
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.2);
            outline: none;
        }
        .input-group textarea {
            height: 70px;
            resize: vertical;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        .controls button {
            font-size: 1.1em;
            font-weight: bold;
            padding: 12px 30px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: all 0.2s;
        }
        .controls button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        #startButton { background-color: #4299E1; color: white; }
        #stopButton { background-color: #F56565; color: white; }
        
        .result-area {
            background-color: #F7FAFC;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }
        #status { font-weight: bold; font-size: 1.1em; margin-bottom: 20px; }
        
        .meters-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .meter-group {
            flex-grow: 1;
            text-align: center;
        }
        .meter-group label {
            font-size: 0.9em;
            font-weight: 500;
            color: #718096;
        }
        .visualizer-container { 
            width: 100%; 
            height: 10px; 
            border-radius: 5px; 
            position: relative; 
            overflow: hidden; 
            background-color: #E2E8F0;
            margin-top: 5px;
        }
        .level-bar { 
            width: 0%; 
            height: 100%; 
            transition: width 0.05s, background-color 0.3s; 
        }
        #volume-bar { background-color: #68D391; }
        #sentiment-bar { background-color: #4299E1; }

        #result { font-size: 1.1em; color: #2D3748; min-height: 1.5em; font-weight: 500; margin-top: 20px; text-align: center; }
        #stats-display { font-size: 0.9em; color: #A0AEC0; min-height: 1.2em; margin-top: 8px; text-align: center;}
        
        #minutes-container { margin-top: 40px; text-align: left; border-top: 1px solid #E2E8F0; padding-top: 20px; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #E2E8F0; padding: 15px; background-color: #F7FAFC; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; }
        
        .minutes-actions { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .minutes-actions button { display: none; }
        #downloadButton { background-color: #38B2AC; color: white; }
        #correctButton { background-color: #ED8936; color: white; }

    </style>
</head>
<body>
    <div class="header">
        <h1>穏やか会議システム</h1>
        <p>AIが会議の心理的安全性をサポートします</p>
    </div>

    <div class="container">
        <div class="input-group">
            <label for="meeting-title">会議タイトル</label>
            <input type="text" id="meeting-title" placeholder="例：第一回 定例会議">
        </div>
        <div class="input-group">
            <label for="meeting-prompt">AIへのヒント</label>
            <textarea id="meeting-prompt" placeholder="会議で使われる専門用語や固有名詞などを入力..."></textarea>
        </div>

        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始</button>
            <button id="stopButton" onclick="stopMicrophone()">終了</button>
        </div>
        
        <div class="result-area">
            <div id="status">マイクの状態: OFF</div>
            <div class="meters-container">
                <div class="meter-group">
                    <label>音量</label>
                    <div class="visualizer-container">
                        <div id="volume-bar" class="level-bar"></div>
                    </div>
                </div>
                <div class="meter-group">
                    <label>雰囲気スコア</label>
                    <div class="visualizer-container">
                        <div id="sentiment-bar" class="level-bar"></div>
                    </div>
                </div>
            </div>
            <div id="result">ここに分析結果が表示されます</div>
            <div id="stats-display">（AIの思考がここに表示されます）</div>
        </div>

        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin-top:20px; max-width:400px;">
        
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div class="minutes-actions">
                <button id="correctButton" onclick="correctWithLLM()" class="controls-button">LLMで校正</button>
                <button id="downloadButton" onclick="downloadMinutes()" class="controls-button">ダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        const SPEAKING_THRESHOLD = 10;
        const SILENCE_DELAY = 750;
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null;

        async function startMicrophone() {
            const statusDiv = document.getElementById('status');
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = '#38A169';
                visualizeAudio();
            } catch (err) {
                statusDiv.textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
                statusDiv.style.color = '#E53E3E';
            }
        }

        async function stopMicrophone() {
            if (isRecording) {
                mediaRecorder.stop();
            }
            const statusDiv = document.getElementById('status');
            const volumeBar = document.getElementById('volume-bar');
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            if (visualizerFrameId) {
                cancelAnimationFrame(visualizerFrameId);
            }
            if (audioContext && audioContext.state !== 'closed') {
                await audioContext.close();
            }
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            volumeBar.style.width = '0%';
            document.getElementById('sentiment-bar').style.width = '50%';
            document.getElementById('sentiment-bar').style.backgroundColor = '#CBD5E0';
            statusDiv.textContent = 'マイクの状態: OFF';
            statusDiv.style.color = 'black';
            document.getElementById('result').textContent = 'ここに分析結果が表示されます';
            document.getElementById('stats-display').textContent = '（AIの思考がここに表示されます）';
        }
        
        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const volumeBar = document.getElementById('volume-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                volumeBar.style.width = (average / 128) * 100 + '%';
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) {
                        startRecording();
                    }
                    if (silenceTimer) {
                        clearTimeout(silenceTimer);
                        silenceTimer = null;
                    }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => {
                            stopRecordingAndSend();
                        }, SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                sendToServer(audioBlob);
            };
        }

        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }

        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            const promptText = document.getElementById('meeting-prompt').value;
            formData.append('prompt', promptText);

            const resultDiv = document.getElementById('result');
            const statsDiv = document.getElementById('stats-display');
            const sentimentBar = document.getElementById('sentiment-bar');
            resultDiv.textContent = '分析中...';
            statsDiv.textContent = '（AIが思考中...）';

            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                
                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                    statsDiv.textContent = '---';
                } else {
                    const filteredText = data.filtered_text;
                    const sentimentScore = parseFloat(data.sentiment_score);

                    if (filteredText && filteredText.trim().length > 0) {
                        resultDiv.textContent = `「${filteredText}」`;
                        statsDiv.textContent = `(雰囲気スコア: ${data.sentiment_score})`;
                        
                        const sentimentWidth = (sentimentScore + 1) / 2 * 100;
                        sentimentBar.style.width = `${sentimentWidth}%`;

                        if (sentimentScore < -0.3) {
                            sentimentBar.style.backgroundColor = '#F56565'; // 赤
                        } else if (sentimentScore > 0.3) {
                            sentimentBar.style.backgroundColor = '#48BB78'; // 緑
                        } else {
                            sentimentBar.style.backgroundColor = '#4299E1'; // 青（中立）
                        }

                    } else {
                        resultDiv.textContent = '（有効な発言なし）';
                        statsDiv.textContent = '---';
                    }
                    
                    if (filteredText && filteredText.trim().length > 0) {
                        const timestamp = new Date().toLocaleTimeString('ja-JP');
                        const logEntry = `[${timestamp}] ${filteredText} (スコア: ${data.sentiment_score})\n`;
                        fullTranscript += logEntry;
                        const minutesLog = document.getElementById('minutes-log');
                        minutesLog.textContent = fullTranscript;
                        minutesLog.scrollTop = minutesLog.scrollHeight;
                    }
                    
                    if (data.is_negative) {
                        document.getElementById('catImage').style.display = 'block';
                    } else {
                        document.getElementById('catImage').style.display = 'none';
                    }
                }
            } catch (err) {
                resultDiv.textContent = `通信エラー: ${err}`;
                statsDiv.textContent = '---';
            }
        }
        
        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLMが校正中です...しばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }

        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-title').value;
            if (meetingTitle.trim() === "") {
                meetingTitle = "議事録";
            }
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>

-->

<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>穏やか会議システム</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans JP', sans-serif; text-align: center; margin: 0; background-color: #f4f7f9; color: #4A5568; }
        .header { width: 100%; height: 250px; background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url("{{ url_for('static', filename='header.jpg') }}"); background-size: cover; background-position: center; display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.4); }
        .header h1 { font-size: 3.5em; font-weight: 700; margin: 0; letter-spacing: 2px; }
        .header p { font-size: 1.2em; font-weight: 400; margin-top: 10px; opacity: 0.9; }
        .container { max-width: 850px; margin: 40px auto 50px auto; background: white; padding: 30px 50px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08); text-align: left; }
        h2 { font-size: 1.5em; color: #2D3748; border-bottom: 2px solid #E2E8F0; padding-bottom: 10px; margin-bottom: 25px; text-align: center; }
        .input-group { margin-bottom: 25px; }
        .input-group label { display: block; text-align: left; font-weight: 500; margin-bottom: 8px; color: #4A5568; }
        .input-group input, .input-group textarea { width: 100%; padding: 12px 15px; font-size: 1em; border: 1px solid #CBD5E0; border-radius: 8px; box-sizing: border-box; transition: all 0.3s; }
        .input-group input:focus, .input-group textarea:focus { border-color: #4299E1; box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.2); outline: none; }
        .input-group textarea { height: 70px; resize: vertical; }
        .controls { display: flex; justify-content: center; gap: 20px; margin: 30px 0; }
        .controls button { font-size: 1.1em; font-weight: bold; padding: 12px 30px; cursor: pointer; border: none; border-radius: 8px; transition: all 0.2s; }
        .controls button:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12); }
        #startButton { background-color: #4299E1; color: white; }
        #stopButton { background-color: #F56565; color: white; }
        .result-area { background-color: #F7FAFC; border: 1px solid #E2E8F0; border-radius: 8px; padding: 20px; margin: 30px 0; }
        #status { font-weight: bold; font-size: 1.1em; margin-bottom: 20px; text-align: center;}
        .meters-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .meter-group { text-align: center; }
        .meter-group label { font-size: 0.9em; font-weight: 500; color: #718096; }
        .visualizer-container { width: 100%; height: 12px; border-radius: 6px; position: relative; overflow: hidden; background-color: #E2E8F0; margin-top: 5px; }
        .level-bar { height: 100%; transition: width 0.2s, background-color 0.3s; display: flex; justify-content: center; align-items: center; color: white; font-size: 0.7em; font-weight: bold; }
        #volume-bar { width: 0%; background-color: #68D391; }
        #text-score-bar, #tone-score-bar, #final-score-bar { width: 50%; background-color: #CBD5E0; }
        #final-score-bar { border-top: 2px solid white; border-bottom: 2px solid white;}
        #result { font-size: 1.1em; color: #2D3748; min-height: 1.5em; font-weight: 500; margin-top: 20px; text-align: center; }
        #minutes-container { margin-top: 40px; text-align: left; border-top: 1px solid #E2E8F0; padding-top: 20px; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #E2E8F0; padding: 15px; background-color: #F7FAFC; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; }
        .minutes-actions { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .minutes-actions button { display: none; }
        #downloadButton { background-color: #38B2AC; color: white; }
        #correctButton { background-color: #ED8936; color: white; }
    </style>
</head>
<body>
    <div class="header">
        <h1>穏やか会議システム</h1>
        <p>AIが会議をサポートします</p>
    </div>
    <div class="container">
        <div class="input-group">
            <label for="meeting-title">会議タイトル</label>
            <input type="text" id="meeting-title" placeholder="例：第一回 定例会議">
        </div>
        <div class="input-group">
            <label for="meeting-prompt">AIへのヒント</label>
            <textarea id="meeting-prompt" placeholder="会議で使われる専門用語や固有名詞などを入力..."></textarea>
        </div>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始</button>
            <button id="stopButton" onclick="stopMicrophone()">終了</button>
        </div>
        <div class="result-area">
            <div id="status">マイクの状態: OFF</div>
            <div class="meters-container">
                <div class="meter-group">
                    <label>音量</label>
                    <div class="visualizer-container"><div id="volume-bar" class="level-bar"></div></div>
                </div>
                <div class="meter-group">
                    <label>言葉のスコア (Text Score)</label>
                    <div class="visualizer-container"><div id="text-score-bar" class="level-bar">0.00</div></div>
                </div>
                <div class="meter-group">
                    <label>声のトーンのスコア (Tone Score)</label>
                    <div class="visualizer-container"><div id="tone-score-bar" class="level-bar">0.00</div></div>
                </div>
                 <div class="meter-group">
                    <label>最終的な雰囲気 (Final Score)</label>
                    <div class="visualizer-container"><div id="final-score-bar" class="level-bar">0.00</div></div>
                </div>
            </div>
            <div id="result">ここに分析結果が表示されます</div>
        </div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin:20px auto; max-width:400px;">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div class="minutes-actions">
                <button id="correctButton" onclick="correctWithLLM()" class="controls-button">LLMで校正</button>
                <button id="downloadButton" onclick="downloadMinutes()" class="controls-button">ダウンロード</button>
            </div>
        </div>
    </div>
    <script>
        const SPEAKING_THRESHOLD = 10, SILENCE_DELAY = 0.75;
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null;

        function updateScoreBar(barElement, score) {
            const widthPercent = (score + 1) / 2 * 100;
            barElement.style.width = `${widthPercent}%`;
            barElement.textContent = `${(score).toFixed(2)}`;
            if (score < -0.3) { barElement.style.backgroundColor = '#F56565'; }
            else if (score > 0.3) { barElement.style.backgroundColor = '#48BB78'; }
            else { barElement.style.backgroundColor = '#4299E1'; }
        }

        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            formData.append('prompt', document.getElementById('meeting-prompt').value);
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '分析中...';
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                } else {
                    resultDiv.textContent = data.filtered_text.trim() ? `「${data.filtered_text}」` : '（有効な発言なし）';
                    updateScoreBar(document.getElementById('text-score-bar'), parseFloat(data.text_score));
                    updateScoreBar(document.getElementById('tone-score-bar'), parseFloat(data.tone_score));
                    updateScoreBar(document.getElementById('final-score-bar'), parseFloat(data.final_score));
                    if (data.filtered_text && data.filtered_text.trim().length > 0) {
                        const timestamp = new Date().toLocaleTimeString('ja-JP');
                        const logEntry = `[${timestamp}] ${data.filtered_text} (Text: ${data.text_score}, Tone: ${data.tone_score}, Final: ${data.final_score})\n`;
                        fullTranscript += logEntry;
                        const minutesLog = document.getElementById('minutes-log');
                        minutesLog.textContent = fullTranscript;
                        minutesLog.scrollTop = minutesLog.scrollHeight;
                    }
                    document.getElementById('catImage').style.display = data.is_negative ? 'block' : 'none';
                }
            } catch (err) {
                resultDiv.textContent = `通信エラー: ${err}`;
            }
        }
        
        async function startMicrophone() {
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = '#38A169';
                visualizeAudio();
            } catch (err) {
                document.getElementById('status').textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
            }
        }

        async function stopMicrophone() {
            if (isRecording) mediaRecorder.stop();
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            document.getElementById('volume-bar').style.width = '0%';
            const neutralColor = '#CBD5E0', neutralWidth = '50%';
            ['text-score-bar', 'tone-score-bar', 'final-score-bar'].forEach(id => {
                const bar = document.getElementById(id);
                bar.style.width = neutralWidth;
                bar.style.backgroundColor = neutralColor;
                bar.textContent = "0.00";
            });
            document.getElementById('status').textContent = 'マイクの状態: OFF';
        }

        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const volumeBar = document.getElementById('volume-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                volumeBar.style.width = (average / 128) * 100 + '%';
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) startRecording();
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => stopRecordingAndSend(), SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
            mediaRecorder.onstop = () => sendToServer(new Blob(audioChunks, { type: 'audio/webm' }));
        }

        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }

        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLMが校正中です...しばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }

        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-title').value;
            if (meetingTitle.trim() === "") meetingTitle = "タイトル未入力";
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
-->
<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>穏やか会議システム</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans JP', sans-serif; text-align: center; margin: 0; background-color: #f4f7f9; color: #4A5568; }
        .header { width: 100%; height: 250px; background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0,0, 0.3)), url("{{ url_for('static', filename='header.jpg') }}"); background-size: cover; background-position: center; display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.4); }
        .header h1 { font-size: 3.5em; font-weight: 700; margin: 0; letter-spacing: 2px; }
        .header p { font-size: 1.2em; font-weight: 400; margin-top: 10px; opacity: 0.9; }
        .container { max-width: 850px; margin: 40px auto 50px auto; background: white; padding: 30px 50px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08); text-align: left; }
        h2 { font-size: 1.5em; color: #2D3748; border-bottom: 2px solid #E2E8F0; padding-bottom: 10px; margin-bottom: 25px; text-align: center; }
        .input-group { margin-bottom: 25px; }
        .input-group label { display: block; text-align: left; font-weight: 500; margin-bottom: 8px; color: #4A5568; }
        .input-group input, .input-group textarea { width: 100%; padding: 12px 15px; font-size: 1em; border: 1px solid #CBD5E0; border-radius: 8px; box-sizing: border-box; transition: all 0.3s; }
        .input-group input:focus, .input-group textarea:focus { border-color: #4299E1; box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.2); outline: none; }
        .input-group textarea { height: 70px; resize: vertical; }
        .controls { display: flex; justify-content: center; gap: 20px; margin: 30px 0; }
        .controls button { font-size: 1.1em; font-weight: bold; padding: 12px 30px; cursor: pointer; border: none; border-radius: 8px; transition: all 0.2s; }
        .controls button:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12); }
        #startButton { background-color: #4299E1; color: white; }
        #stopButton { background-color: #F56565; color: white; }
        .result-area { background-color: #F7FAFC; border: 1px solid #E2E8F0; border-radius: 8px; padding: 20px; margin: 30px 0; }
        #status { font-weight: bold; font-size: 1.1em; margin-bottom: 20px; text-align: center;}
        .meters-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .meter-group { text-align: center; }
        .meter-group label { font-size: 0.9em; font-weight: 500; color: #718096; }
        .visualizer-container { width: 100%; height: 12px; border-radius: 6px; position: relative; overflow: hidden; background-color: #E2E8F0; margin-top: 5px; }
        .level-bar { height: 100%; transition: width 0.2s, background-color 0.3s; display: flex; justify-content: center; align-items: center; color: white; font-size: 0.7em; font-weight: bold; }
        #volume-bar { width: 0%; background-color: #68D391; }
        #text-score-bar, #tone-score-bar, #final-score-bar { width: 50%; background-color: #CBD5E0; }
        #final-score-bar { border-top: 2px solid white; border-bottom: 2px solid white;}
        #result { font-size: 1.1em; color: #2D3748; min-height: 1.5em; font-weight: 500; margin-top: 20px; text-align: center; }
        #minutes-container { margin-top: 40px; text-align: left; border-top: 1px solid #E2E8F0; padding-top: 20px; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #E2E8F0; padding: 15px; background-color: #F7FAFC; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; }
        .minutes-actions { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .minutes-actions button { display: none; }
        #downloadButton { background-color: #38B2AC; color: white; }
        #correctButton { background-color: #ED8936; color: white; }
    </style>
</head>
<body>
    <div class="header">
        <h1>穏やか会議システム</h1>
        <p>AIが会議の心理的安全性をサポートします</p>
    </div>
    <div class="container">
        <div class="input-group">
            <label for="meeting-title">会議タイトル</label>
            <input type="text" id="meeting-title" placeholder="例：第一回 定例会議">
        </div>
        <div class="input-group">
            <label for="meeting-prompt">AIへのヒント</label>
            <textarea id="meeting-prompt" placeholder="会議で使われる専門用語や固有名詞などを入力..."></textarea>
        </div>
        <div class="controls">
            <button id="startButton" onclick="startMicrophone()">開始</button>
            <button id="stopButton" onclick="stopMicrophone()">終了</button>
        </div>
        <div class="result-area">
            <div id="status">マイクの状態: OFF</div>
            <div class="meters-container">
                <div class="meter-group">
                    <label>音量</label>
                    <div class="visualizer-container"><div id="volume-bar" class="level-bar"></div></div>
                </div>
                <div class="meter-group">
                    <label>言葉のスコア (Text Score)</label>
                    <div class="visualizer-container"><div id="text-score-bar" class="level-bar">0.00</div></div>
                </div>
                <div class="meter-group">
                    <label>声のトーンのスコア (Tone Score)</label>
                    <div class="visualizer-container"><div id="tone-score-bar" class="level-bar">0.00</div></div>
                </div>
                 <div class="meter-group">
                    <label>最終的な雰囲気 (Final Score)</label>
                    <div class="visualizer-container"><div id="final-score-bar" class="level-bar">0.00</div></div>
                </div>
            </div>
            <div id="result">ここに分析結果が表示されます</div>
        </div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin:20px auto; max-width:400px;">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div class="minutes-actions">
                <button id="correctButton" onclick="correctWithLLM()" class="controls-button">LLMで校正</button>
                <button id="downloadButton" onclick="downloadMinutes()" class="controls-button">ダウンロード</button>
            </div>
        </div>
    </div>
    <script>
        const SPEAKING_THRESHOLD = 10;
        const SILENCE_DELAY = 1000;
        // ★★★ 最低録音時間を設定 (ミリ秒) ★★★
        const MIN_RECORDING_TIME = 300; // 0.3秒

        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null;
        // ★★★ 録音開始時間を保持する変数を追加 ★★★
        let recordingStartTime = 0;

        // --- 録音開始の関数を修正 ---
        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            
            // ★ 録音開始時間を記録
            recordingStartTime = Date.now();

            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();

            const audioChunks = [];
            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            mediaRecorder.onstop = () => {
                if (audioChunks.length > 0) {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    sendToServer(audioBlob);
                }
            };
        }

        // --- 録音停止＆送信の関数を修正 ---
        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                // ★ 録音時間が最低時間に満たない場合は、少し待ってから停止する
                const elapsedTime = Date.now() - recordingStartTime;
                const timeToWait = MIN_RECORDING_TIME - elapsedTime;

                if (timeToWait > 0) {
                    setTimeout(() => {
                        mediaRecorder.stop();
                    }, timeToWait);
                } else {
                    mediaRecorder.stop();
                }
                
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }
        
        // --- ここから下は変更ありません ---
        function updateScoreBar(barElement, score) {
            const widthPercent = (score + 1) / 2 * 100;
            barElement.style.width = `${widthPercent}%`;
            barElement.textContent = `${(score).toFixed(2)}`;
            if (score < -0.3) { barElement.style.backgroundColor = '#F56565'; }
            else if (score > 0.3) { barElement.style.backgroundColor = '#48BB78'; }
            else { barElement.style.backgroundColor = '#4299E1'; }
        }

        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            formData.append('prompt', document.getElementById('meeting-prompt').value);
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '分析中...';
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) {
                    resultDiv.textContent = `エラー: ${data.error}`;
                } else {
                    resultDiv.textContent = data.filtered_text.trim() ? `「${data.filtered_text}」` : '（有効な発言なし）';
                    updateScoreBar(document.getElementById('text-score-bar'), parseFloat(data.text_score));
                    updateScoreBar(document.getElementById('tone-score-bar'), parseFloat(data.tone_score));
                    updateScoreBar(document.getElementById('final-score-bar'), parseFloat(data.final_score));
                    if (data.filtered_text && data.filtered_text.trim().length > 0) {
                        const timestamp = new Date().toLocaleTimeString('ja-JP');
                        const logEntry = `[${timestamp}] ${data.filtered_text} (Text: ${data.text_score}, Tone: ${data.tone_score}, Final: ${data.final_score})\n`;
                        fullTranscript += logEntry;
                        const minutesLog = document.getElementById('minutes-log');
                        minutesLog.textContent = fullTranscript;
                        minutesLog.scrollTop = minutesLog.scrollHeight;
                    }
                    document.getElementById('catImage').style.display = data.is_negative ? 'block' : 'none';
                }
            } catch (err) {
                resultDiv.textContent = `通信エラー: ${err}`;
            }
        }
        
        async function startMicrophone() {
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                const constraints = { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = '#38A169';
                visualizeAudio();
            } catch (err) {
                document.getElementById('status').textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
            }
        }

        async function stopMicrophone() {
            if (isRecording) mediaRecorder.stop();
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            document.getElementById('volume-bar').style.width = '0%';
            const neutralColor = '#CBD5E0', neutralWidth = '50%';
            ['text-score-bar', 'tone-score-bar', 'final-score-bar'].forEach(id => {
                const bar = document.getElementById(id);
                bar.style.width = neutralWidth;
                bar.style.backgroundColor = neutralColor;
                bar.textContent = "0.00";
            });
            document.getElementById('status').textContent = 'マイクの状態: OFF';
        }

        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const volumeBar = document.getElementById('volume-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                volumeBar.style.width = (average / 128) * 100 + '%';
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) startRecording();
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => stopRecordingAndSend(), SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLMが校正中です...しばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }

        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-title').value;
            if (meetingTitle.trim() === "") meetingTitle = "議事録";
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
-->

<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>穏やか会議システム</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans JP', sans-serif; text-align: center; margin: 0; background-color: #f4f7f9; color: #4A5568; }
        .header { width: 100%; height: 200px; background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0,0, 0.3)), url("{{ url_for('static', filename='header.jpg') }}"); background-size: cover; background-position: center; display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.4); }
        .header h1 { font-size: 3.5em; }
        .container { max-width: 850px; margin: 40px auto 50px auto; background: white; padding: 30px 50px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08); text-align: left; }
        h2 { font-size: 1.5em; color: #2D3748; border-bottom: 2px solid #E2E8F0; padding-bottom: 10px; margin-bottom: 25px; text-align: center; }
        .input-group { margin-bottom: 20px; }
        .input-group label { display: block; text-align: left; font-weight: 500; margin-bottom: 8px; }
        .input-group input, .input-group textarea { width: 100%; padding: 12px 15px; font-size: 1em; border: 1px solid #CBD5E0; border-radius: 8px; box-sizing: border-box; }
        .calibration-section { background-color: #EDF2F7; border: 1px solid #E2E8F0; padding: 20px; margin-bottom: 30px; border-radius: 8px; }
        .calibration-controls { display: flex; justify-content: space-around; flex-wrap: wrap; gap: 15px; }
        .calibration-controls button { flex-grow: 1; padding: 10px 15px; font-size: 1em; font-weight: bold; cursor: pointer; border: 2px solid transparent; border-radius: 8px; transition: all 0.2s; }
        .cal-joy { background-color: #F6E05E; color: #975A16; }
        .cal-anger { background-color: #F56565; color: white; }
        .cal-sadness { background-color: #63B3ED; color: white; }
        .cal-normal { background-color: #A0AEC0; color: white; }
        .cal-done { background-color: #48BB78; color: white; border-color: #2F855A; transform: scale(1.05); }
        .main-controls { text-align: center; }
        .main-controls button { font-size: 1.1em; font-weight: bold; padding: 12px 30px; cursor: pointer; border: none; border-radius: 8px; transition: all 0.2s; margin: 5px;}
        #startButton { background-color: #48BB78; color: white; }
        #stopButton { background-color: #F56565; color: white; }
        .result-area { background-color: #F7FAFC; border: 1px solid #E2E8F0; border-radius: 8px; padding: 20px; margin: 30px 0; }
        #status { font-weight: bold; font-size: 1.1em; margin-bottom: 20px; text-align: center;}
        .meters-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .meter-group { text-align: center; }
        .meter-group label { font-size: 0.9em; font-weight: 500; color: #718096; }
        .visualizer-container { width: 100%; height: 12px; border-radius: 6px; position: relative; overflow: hidden; background-color: #E2E8F0; margin-top: 5px; }
        .level-bar { height: 100%; transition: width 0.2s, background-color 0.3s; display: flex; justify-content: center; align-items: center; color: white; font-size: 0.7em; font-weight: bold; }
        #volume-bar, #text-score-bar, #tone-score-bar, #final-score-bar { width: 50%; background-color: #CBD5E0; }
        #volume-bar {width: 0%; background-color: #68D391;}
        #final-score-bar { border-top: 2px solid white; border-bottom: 2px solid white;}
        #result { font-size: 1.1em; color: #2D3748; min-height: 1.5em; font-weight: 500; margin-top: 20px; text-align: center; }
        #minutes-container { margin-top: 40px; text-align: left; border-top: 1px solid #E2E8F0; padding-top: 20px; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #E2E8F0; padding: 15px; background-color: #F7FAFC; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; }
        .minutes-actions { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .minutes-actions button { display: none; }
        #downloadButton { background-color: #38B2AC; color: white; }
        #correctButton { background-color: #ED8936; color: white; }
    </style>
</head>
<body>
    <div class="header"><h1>穏やか会議システム</h1></div>
    <div class="container">
        <div class="input-group">
            <label for="meeting-prompt">会議タイトル・AIへのヒント</label>
            <input type="text" id="meeting-prompt" placeholder="会議のタイトルや、AIに認識させたい専門用語などを入力">
        </div>
        
        <div class="calibration-section">
            <h2>感情辞書の作成</h2>
            <p style="text-align: center; margin-top:-15px; margin-bottom: 20px;">各ボタンを押し、それぞれの感情を込めて5秒間話してください。</p>
            <div class="calibration-controls">
                <button id="cal-joy" class="cal-joy" onclick="startCalibration('joy')">「喜び」を録音</button>
                <button id="cal-anger" class="cal-anger" onclick="startCalibration('anger')">「怒り」を録音</button>
                <button id="cal-sadness" class="cal-sadness" onclick="startCalibration('sadness')">「悲しみ」を録音</button>
                <button id="cal-normal" class="cal-normal" onclick="startCalibration('normal')">「普通」の声を録音</button>
            </div>
        </div>

        <h2>会議の分析</h2>
        <div class="main-controls">
            <button id="startButton" onclick="startAnalysis()">分析開始</button>
            <button id="stopButton" onclick="stopAnalysis()">分析終了</button>
        </div>
        <div class="result-area">
            <div id="status">マイクの状態: OFF</div>
            <div class="meters-container">
                 <div class="meter-group"><label>音量</label><div class="visualizer-container"><div id="volume-bar" class="level-bar"></div></div></div>
                 <div class="meter-group"><label>言葉のスコア</label><div class="visualizer-container"><div id="text-score-bar" class="level-bar">0.00</div></div></div>
                 <div class="meter-group"><label>抑揚・トーン</label><div class="visualizer-container"><div id="tone-score-bar" class="level-bar">0.00</div></div></div>
                 <div class="meter-group"><label>雰囲気</label><div class="visualizer-container"><div id="final-score-bar" class="level-bar">0.00</div></div></div>
            </div>
            <div id="result">分析結果を表示</div>
        </div>
        
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin:20px auto; max-width:400px; border-radius: 8px;">
        
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div class="minutes-actions">
                <button id="correctButton" onclick="correctWithLLM()">LLM(大規模言語モデル)で校正</button>
                <button id="downloadButton" onclick="downloadMinutes()">テキストをダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        const SPEAKING_THRESHOLD = 10, SILENCE_DELAY = 750, MIN_RECORDING_TIME = 300;
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null, recordingStartTime = 0;
        let calibratedEmotions = new Set();

        async function startCalibration(emotion) {
            const button = document.getElementById(`cal-${emotion}`);
            button.textContent = "録音中...";
            button.disabled = true;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const rec = new MediaRecorder(stream);
                const chunks = [];
                rec.ondataavailable = e => chunks.push(e.data);
                rec.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    const formData = new FormData();
                    formData.append('audio', blob);
                    const response = await fetch(`/calibrate?emotion=${emotion}`, { method: 'POST', body: formData });
                    const result = await response.json();
                    if (result.status === 'success') {
                        alert(`「${emotion}」の調整完了！`);
                        calibratedEmotions.add(emotion);
                        button.classList.add('cal-done');
                        button.textContent = `「${emotion}」登録完了`;
                    } else { 
                        alert(`エラー: ${result.error}`);
                        button.textContent = `「${emotion}」を録音`;
                        button.disabled = false;
                    }
                    stream.getTracks().forEach(track => track.stop());
                };
                rec.start();
                setTimeout(() => { if(rec.state === 'recording') rec.stop() }, 5000);
            } catch (err) {
                alert(`マイクエラー: ${err}`);
                button.textContent = `「${emotion}」を録音`;
                button.disabled = false;
            }
        }
        
        async function startAnalysis() {
            if (calibratedEmotions.size < 4) {
                alert("分析を開始する前に、4つ全ての感情を登録してください。");
                return;
            }
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = '#38A169';
                visualizeAudio();
            } catch (err) {
                document.getElementById('status').textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
            }
        }

        async function stopAnalysis() {
            if (isRecording) mediaRecorder.stop();
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            document.getElementById('volume-bar').style.width = '0%';
            const neutralColor = '#CBD5E0', neutralWidth = '50%';
            ['text-score-bar', 'tone-score-bar', 'final-score-bar'].forEach(id => {
                const bar = document.getElementById(id);
                bar.style.width = neutralWidth;
                bar.style.backgroundColor = neutralColor;
                bar.textContent = "0.00";
            });
            document.getElementById('status').textContent = 'マイクの状態: OFF';
        }

        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const volumeBar = document.getElementById('volume-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                if (!analyser) return;
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                volumeBar.style.width = (average / 128) * 100 + '%';
                volumeBar.textContent = Math.round(average);
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) startRecording();
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => stopRecordingAndSend(), SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            recordingStartTime = Date.now();
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
            mediaRecorder.onstop = () => { if (audioChunks.length > 0) sendToServer(new Blob(audioChunks, { type: 'audio/webm' })); };
        }

        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const elapsedTime = Date.now() - recordingStartTime;
                const timeToWait = MIN_RECORDING_TIME - elapsedTime;
                if (timeToWait > 0) { setTimeout(() => { mediaRecorder.stop(); }, timeToWait); } 
                else { mediaRecorder.stop(); }
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }
        
        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            formData.append('prompt', document.getElementById('meeting-prompt').value);
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '分析中...';
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) { resultDiv.textContent = `エラー: ${data.error}`; return; }
                resultDiv.textContent = data.filtered_text.trim() ? `「${data.filtered_text}」` : '（ハルシネーションとして結果を切り捨てます）';
                updateScoreBar(document.getElementById('text-score-bar'), parseFloat(data.text_score));
                updateScoreBar(document.getElementById('tone-score-bar'), parseFloat(data.tone_score));
                updateScoreBar(document.getElementById('final-score-bar'), parseFloat(data.final_score));
                if (data.filtered_text && data.filtered_text.trim().length > 0) {
                    const timestamp = new Date().toLocaleTimeString('ja-JP');
                    const logEntry = `[${timestamp}] ${data.filtered_text} (Final Score: ${data.final_score})\n`;
                    fullTranscript += logEntry;
                    document.getElementById('minutes-log').textContent = fullTranscript;
                    document.getElementById('minutes-log').scrollTop = document.getElementById('minutes-log').scrollHeight;
                }
                
                document.getElementById('catImage').style.display = data.is_negative ? 'block' : 'none';


            } catch (err) { resultDiv.textContent = `通信エラー: ${err}`; }
        }

        function updateScoreBar(barElement, score) {
            const widthPercent = (score + 1) / 2 * 100;
            barElement.style.width = `${widthPercent}%`;
            barElement.textContent = `${(score).toFixed(2)}`;
            if (score < -0.3) { barElement.style.backgroundColor = '#F56565'; }
            else if (score > 0.3) { barElement.style.backgroundColor = '#48BB78'; }
            else { barElement.style.backgroundColor = '#4299E1'; }
        }

        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLM(大規模言語モデル)が校正中です...しばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }

        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-prompt').value.split(' ')[0] || "議事録";
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>

-->

<!--
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>穏やか会議システム</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans JP', sans-serif; text-align: center; margin: 0; background-color: #f4f7f9; color: #4A5568; }
        .header { width: 100%; height: 200px; background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0,0, 0.3)), url("{{ url_for('static', filename='header.jpg') }}"); background-size: cover; background-position: center; display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.4); }
        .header h1 { font-size: 3.5em; }
        .container { max-width: 850px; margin: 40px auto 50px auto; background: white; padding: 30px 50px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08); text-align: left; }
        h2 { font-size: 1.5em; color: #2D3748; border-bottom: 2px solid #E2E8F0; padding-bottom: 10px; margin-bottom: 25px; text-align: center; }
        .input-group { margin-bottom: 20px; }
        .input-group label { display: block; text-align: left; font-weight: 500; margin-bottom: 8px; }
        .input-group input, .input-group textarea { width: 100%; padding: 12px 15px; font-size: 1em; border: 1px solid #CBD5E0; border-radius: 8px; box-sizing: border-box; }
        .calibration-section { background-color: #EDF2F7; border: 1px solid #E2E8F0; padding: 20px; margin-bottom: 30px; border-radius: 8px; }
        .calibration-controls { display: flex; justify-content: space-around; flex-wrap: wrap; gap: 15px; }
        .calibration-controls button { flex-grow: 1; padding: 10px 15px; font-size: 1em; font-weight: bold; cursor: pointer; border: 2px solid transparent; border-radius: 8px; transition: all 0.2s; }
        .cal-joy { background-color: #F6E05E; color: #975A16; }
        .cal-anger { background-color: #F56565; color: white; }
        .cal-sadness { background-color: #63B3ED; color: white; }
        .cal-normal { background-color: #A0AEC0; color: white; }
        .cal-done { background-color: #48BB78; color: white; border-color: #2F855A; transform: scale(1.05); }
        .main-controls { text-align: center; }
        .main-controls button { font-size: 1.1em; font-weight: bold; padding: 12px 30px; cursor: pointer; border: none; border-radius: 8px; transition: all 0.2s; margin: 5px;}
        #startButton { background-color: #48BB78; color: white; }
        #stopButton { background-color: #F56565; color: white; }
        .result-area { background-color: #F7FAFC; border: 1px solid #E2E8F0; border-radius: 8px; padding: 20px; margin: 30px 0; }
        #status { font-weight: bold; font-size: 1.1em; margin-bottom: 20px; text-align: center;}
        .meters-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .meter-group { text-align: center; }
        .meter-group label { font-size: 0.9em; font-weight: 500; color: #718096; }
        .visualizer-container { width: 100%; height: 12px; border-radius: 6px; position: relative; overflow: hidden; background-color: #E2E8F0; margin-top: 5px; }
        .level-bar { height: 100%; transition: width 0.2s, background-color 0.3s; display: flex; justify-content: center; align-items: center; color: white; font-size: 0.7em; font-weight: bold; }
        #volume-bar, #text-score-bar, #tone-score-bar, #final-score-bar { width: 50%; background-color: #CBD5E0; }
        #volume-bar {width: 0%; background-color: #68D391;}
        #final-score-bar { border-top: 2px solid white; border-bottom: 2px solid white;}
        #result { font-size: 1.1em; color: #2D3748; min-height: 1.5em; font-weight: 500; margin-top: 20px; text-align: center; }
        #minutes-container { margin-top: 40px; text-align: left; border-top: 1px solid #E2E8F0; padding-top: 20px; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #E2E8F0; padding: 15px; background-color: #F7FAFC; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; }
        .minutes-actions { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .minutes-actions button { display: none; }
        #downloadButton { background-color: #38B2AC; color: white; }
        #correctButton { background-color: #ED8936; color: white; }
    </style>
</head>
<body>
    <div class="header"><h1>穏やか会議システム</h1></div>
    <div class="container">
        <div class="input-group">
            <label for="meeting-prompt">会議タイトル・AIへのヒント</label>
            <input type="text" id="meeting-prompt" placeholder="会議のタイトルや、AIに認識させたい専門用語などを入力">
        </div>
        
        <div class="calibration-section">
            <h2>Step 1: 声の感情辞書を作成 (オプション)</h2>
            <p style="text-align: center; margin-top:-15px; margin-bottom: 20px;">
                <b>より正確なトーン分析のために、あなたの声をAIに学習させることを推奨します。</b><br>
                <small>(このステップを省略しても、一般的な基準値で分析は開始できます)</small>
            </p>
            <div class="calibration-controls">
                <button id="cal-joy" class="cal-joy" onclick="startCalibration('joy')">「喜び」を録音</button>
                <button id="cal-anger" class="cal-anger" onclick="startCalibration('anger')">「怒り」を録音</button>
                <button id="cal-sadness" class="cal-sadness" onclick="startCalibration('sadness')">「悲しみ」を録音</button>
                <button id="cal-normal" class="cal-normal" onclick="startCalibration('normal')">「普通」の声を録音</button>
            </div>
        </div>

        <h2>Step 2: 会議の分析</h2>
        <div class="main-controls">
            <button id="startButton" onclick="startAnalysis()">分析開始</button>
            <button id="stopButton" onclick="stopAnalysis()">分析終了</button>
        </div>
        <div class="result-area">
            <div id="status">マイクの状態: OFF</div>
            <div class="meters-container">
                 <div class="meter-group"><label>音量</label><div class="visualizer-container"><div id="volume-bar" class="level-bar"></div></div></div>
                 <div class="meter-group"><label>言葉のスコア</label><div class="visualizer-container"><div id="text-score-bar" class="level-bar">0.00</div></div></div>
                 <div class="meter-group"><label>抑揚・トーン</label><div class="visualizer-container"><div id="tone-score-bar" class="level-bar">0.00</div></div></div>
                 <div class="meter-group"><label>雰囲気</label><div class="visualizer-container"><div id="final-score-bar" class="level-bar">0.00</div></div></div>
            </div>
            <div id="result">分析結果を表示</div>
        </div>
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin:20px auto; max-width:400px; border-radius: 8px;">
        <div id="minutes-container">
            <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div class="minutes-actions">
                <button id="correctButton" onclick="correctWithLLM()">LLM(大規模言語モデル)で校正</button>
                <button id="downloadButton" onclick="downloadMinutes()">テキストをダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        const SPEAKING_THRESHOLD = 10, SILENCE_DELAY = 750, MIN_RECORDING_TIME = 300;
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null, recordingStartTime = 0;
        let calibratedEmotions = new Set();

        async function startCalibration(emotion) {
            const button = document.getElementById(`cal-${emotion}`);
            button.textContent = "録音中...";
            button.disabled = true;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const rec = new MediaRecorder(stream);
                const chunks = [];
                rec.ondataavailable = e => chunks.push(e.data);
                rec.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    const formData = new FormData();
                    formData.append('audio', blob);
                    const response = await fetch(`/calibrate?emotion=${emotion}`, { method: 'POST', body: formData });
                    const result = await response.json();
                    if (result.status === 'success') {
                        alert(`「${emotion}」の調整完了！`);
                        calibratedEmotions.add(emotion);
                        button.classList.add('cal-done');
                        button.textContent = `「${emotion}」登録完了`;
                    } else { 
                        alert(`エラー: ${result.error}`);
                        button.textContent = `「${emotion}」を録音`;
                        button.disabled = false;
                    }
                    stream.getTracks().forEach(track => track.stop());
                };
                rec.start();
                setTimeout(() => { if(rec.state === 'recording') rec.stop() }, 5000);
            } catch (err) {
                alert(`マイクエラー: ${err}`);
                button.textContent = `「${emotion}」を録音`;
                button.disabled = false;
            }
        }
        
        async function startAnalysis() {
            // ★★★ キャリブレーションを強制するアラートを削除 ★★★
            if (mediaStream) return;
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = 'マイクの状態: ON (発言を待っています)';
                statusDiv.style.color = '#38A169';
                visualizeAudio();
            } catch (err) {
                document.getElementById('status').textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
            }
        }

        async function stopAnalysis() {
            if (isRecording) mediaRecorder.stop();
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            document.getElementById('volume-bar').style.width = '0%';
            document.getElementById('volume-bar').textContent = '';
            const neutralColor = '#CBD5E0', neutralWidth = '50%';
            ['text-score-bar', 'tone-score-bar', 'final-score-bar'].forEach(id => {
                const bar = document.getElementById(id);
                bar.style.width = neutralWidth;
                bar.style.backgroundColor = neutralColor;
                bar.textContent = "0.00";
            });
            document.getElementById('status').textContent = 'マイクの状態: OFF';
        }

        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const volumeBar = document.getElementById('volume-bar');
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                if (!analyser) return;
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength;
                volumeBar.style.width = (average / 128) * 100 + '%';
                volumeBar.textContent = Math.round(average);
                if (average > SPEAKING_THRESHOLD) {
                    if (!isRecording) startRecording();
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
                } else {
                    if (isRecording && !silenceTimer) {
                        silenceTimer = setTimeout(() => stopRecordingAndSend(), SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            recordingStartTime = Date.now();
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
            mediaRecorder.onstop = () => { if (audioChunks.length > 0) sendToServer(new Blob(audioChunks, { type: 'audio/webm' })); };
        }

        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const elapsedTime = Date.now() - recordingStartTime;
                const timeToWait = MIN_RECORDING_TIME - elapsedTime;
                if (timeToWait > 0) { setTimeout(() => { mediaRecorder.stop(); }, timeToWait); } 
                else { mediaRecorder.stop(); }
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }
        
        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            formData.append('prompt', document.getElementById('meeting-prompt').value);
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '分析中...';
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) { resultDiv.textContent = `エラー: ${data.error}`; return; }
                resultDiv.textContent = data.filtered_text.trim() ? `「${data.filtered_text}」` : '（ハルシネーションとして結果を切り捨てます）';
                updateScoreBar(document.getElementById('text-score-bar'), parseFloat(data.text_score));
                updateScoreBar(document.getElementById('tone-score-bar'), parseFloat(data.tone_score));
                updateScoreBar(document.getElementById('final-score-bar'), parseFloat(data.final_score));
                if (data.filtered_text && data.filtered_text.trim().length > 0) {
                    const timestamp = new Date().toLocaleTimeString('ja-JP');
                    const logEntry = `[${timestamp}] ${data.filtered_text} (Final Score: ${data.final_score})\n`;
                    fullTranscript += logEntry;
                    document.getElementById('minutes-log').textContent = fullTranscript;
                    document.getElementById('minutes-log').scrollTop = document.getElementById('minutes-log').scrollHeight;
                }
                
                document.getElementById('catImage').style.display = data.is_negative ? 'block' : 'none';

            } catch (err) { resultDiv.textContent = `通信エラー: ${err}`; }
        }

        function updateScoreBar(barElement, score) {
            const widthPercent = (score + 1) / 2 * 100;
            barElement.style.width = `${widthPercent}%`;
            barElement.textContent = `${(score).toFixed(2)}`;
            if (score < -0.3) { barElement.style.backgroundColor = '#F56565'; }
            else if (score > 0.3) { barElement.style.backgroundColor = '#48BB78'; }
            else { barElement.style.backgroundColor = '#4299E1'; }
        }

        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLM(大規模言語モデル)が校正中です...しばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }

        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-prompt').value.split(' ')[0] || "議事録";
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
-->


<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8"> <title>穏やか会議システム</title> <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap'); /* 日本語をキレイに表示するためのフォントを読み込み */
        body { font-family: 'Noto Sans JP', sans-serif; text-align: center; margin: 0; background-color: #f4f7f9; color: #4A5568; }
        .header { width: 100%; height: 200px; background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0,0, 0.3)), url("{{ url_for('static', filename='header.jpg') }}"); background-size: cover; background-position: center; display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; text-shadow: 0 2px 10px rgba(0, 0, 0, 0.4); }
        .header h1 { font-size: 3.5em; }
        .container { max-width: 850px; margin: 40px auto 50px auto; background: white; padding: 30px 50px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08); text-align: left; }
        h2 { font-size: 1.5em; color: #2D3748; border-bottom: 2px solid #E2E8F0; padding-bottom: 10px; margin-bottom: 25px; text-align: center; }
        .input-group { margin-bottom: 20px; }
        .input-group label { display: block; text-align: left; font-weight: 500; margin-bottom: 8px; }
        .input-group input, .input-group textarea { width: 100%; padding: 12px 15px; font-size: 1em; border: 1px solid #CBD5E0; border-radius: 8px; box-sizing: border-box; }
        .calibration-section { background-color: #EDF2F7; border: 1px solid #E2E8F0; padding: 20px; margin-bottom: 30px; border-radius: 8px; }
        .calibration-controls { display: flex; justify-content: space-around; flex-wrap: wrap; gap: 15px; }
        .calibration-controls button { flex-grow: 1; padding: 10px 15px; font-size: 1em; font-weight: bold; cursor: pointer; border: 2px solid transparent; border-radius: 8px; transition: all 0.2s; }
        /* 各感情ボタンの色を設定 */
        .cal-joy { background-color: #F6E05E; color: #975A16; }
        .cal-anger { background-color: #F56565; color: white; }
        .cal-sadness { background-color: #63B3ED; color: white; }
        .cal-normal { background-color: #A0AEC0; color: white; }
        .cal-done { background-color: #48BB78; color: white; border-color: #2F855A; transform: scale(1.05); } /* 登録完了したボタンの見た目 */
        .main-controls { text-align: center; }
        .main-controls button { font-size: 1.1em; font-weight: bold; padding: 12px 30px; cursor: pointer; border: none; border-radius: 8px; transition: all 0.2s; margin: 5px;}
        #startButton { background-color: #48BB78; color: white; }
        #stopButton { background-color: #F56565; color: white; }
        .result-area { background-color: #F7FAFC; border: 1px solid #E2E8F0; border-radius: 8px; padding: 20px; margin: 30px 0; }
        #status { font-weight: bold; font-size: 1.1em; margin-bottom: 20px; text-align: center;}
        /* メーターのデザイン */
        .meters-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .meter-group { text-align: center; }
        .meter-group label { font-size: 0.9em; font-weight: 500; color: #718096; }
        .visualizer-container { width: 100%; height: 12px; border-radius: 6px; position: relative; overflow: hidden; background-color: #E2E8F0; margin-top: 5px; }
        .level-bar { height: 100%; transition: width 0.2s, background-color 0.3s; display: flex; justify-content: center; align-items: center; color: white; font-size: 0.7em; font-weight: bold; }
        #volume-bar, #text-score-bar, #tone-score-bar, #final-score-bar { width: 50%; background-color: #CBD5E0; }
        #volume-bar {width: 0%; background-color: #68D391;}
        #final-score-bar { border-top: 2px solid white; border-bottom: 2px solid white;}
        #result { font-size: 1.1em; color: #2D3748; min-height: 1.5em; font-weight: 500; margin-top: 20px; text-align: center; }
        #minutes-container { margin-top: 40px; text-align: left; border-top: 1px solid #E2E8F0; padding-top: 20px; }
        #minutes-log { height: 200px; overflow-y: scroll; border: 1px solid #E2E8F0; padding: 15px; background-color: #F7FAFC; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; }
        .minutes-actions { text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .minutes-actions button { display: none; }
        #downloadButton { background-color: #38B2AC; color: white; }
        #correctButton { background-color: #ED8936; color: white; }
    </style>
</head>
<body>
    <div class="header"><h1>穏やか会議システム</h1></div> <div class="container"> <div class="input-group">
            <label for="meeting-prompt">会議タイトル・AIへのヒント</label>
            <input type="text" id="meeting-prompt" placeholder="会議のタイトルや、AIに認識させたい専門用語などを入力">
        </div>
        
        <div class="calibration-section"> <h2>感情辞書の作成</h2>
            <p style="text-align: center; margin-top:-15px; margin-bottom: 20px;">
                <b>より正確なトーン分析のために、あなたの声をAIに学習させることを推奨します。</b><br>
                <small>(このステップを省略しても、一般的な基準値で分析は開始できます)</small>
            </p>
            <div class="calibration-controls"> <button id="cal-joy" class="cal-joy" onclick="startCalibration('joy')">「喜び」を録音</button>
                <button id="cal-anger" class="cal-anger" onclick="startCalibration('anger')">「怒り」を録音</button>
                <button id="cal-sadness" class="cal-sadness" onclick="startCalibration('sadness')">「悲しみ」を録音</button>
                <button id="cal-normal" class="cal-normal" onclick="startCalibration('normal')">「普通」の声を録音</button>
            </div>
        </div>

        <h2>会議の分析</h2>
        <div class="main-controls">
            <button id="startButton" onclick="startAnalysis()">分析開始</button>
            <button id="stopButton" onclick="stopAnalysis()">分析終了</button>
        </div>
        <div class="result-area"> <div id="status">マイクの状態: OFF</div>
            <div class="meters-container"> <div class="meter-group"><label>音量</label><div class="visualizer-container"><div id="volume-bar" class="level-bar"></div></div></div>
                 <div class="meter-group"><label>言葉のスコア</label><div class="visualizer-container"><div id="text-score-bar" class="level-bar">0.00</div></div></div>
                 <div class="meter-group"><label>抑揚・トーン</label><div class="visualizer-container"><div id="tone-score-bar" class="level-bar">0.00</div></div></div>
                 <div class="meter-group"><label>雰囲気</label><div class="visualizer-container"><div id="final-score-bar" class="level-bar">0.00</div></div></div>
            </div>
            <div id="result">分析結果を表示</div>
        </div>
        
        <img id="catImage" src="{{ url_for('static', filename='cat.gif') }}" alt="A cute cat" style="display:none; margin:20px auto; max-width:400px; border-radius: 8px;">
        
        <div id="minutes-container"> <h2>議事録</h2>
            <div id="minutes-log"></div>
            <div class="minutes-actions">
                <button id="correctButton" onclick="correctWithLLM()">LLM(大規模言語モデル)で校正</button>
                <button id="downloadButton" onclick="downloadMinutes()">テキストをダウンロード</button>
            </div>
        </div>
    </div>

    <script>
        // --- プログラム全体で使う大事な設定値 ---
        const SPEAKING_THRESHOLD = 10; // これ以上の音量なら「話してる」と判断
        const SILENCE_DELAY = 750;     // 0.75秒黙ったら「話おわった」と判断
        const MIN_RECORDING_TIME = 300; // 最低でも0.3秒は録音する（ファイルが壊れるのを防ぐ）

        // --- プログラム全体で使う、データをしまっておくための「変数」という箱 ---
        let mediaStream = null, audioContext = null, analyser = null, visualizerFrameId = null, fullTranscript = "";
        let mediaRecorder = null, isRecording = false, silenceTimer = null, recordingStartTime = 0;
        let calibratedEmotions = new Set(); // キャリブレーションが終わった感情を覚えておく

        // 「喜び」などのキャリブレーションボタンが押されたときに動く関数
        async function startCalibration(emotion) {
            const button = document.getElementById(`cal-${emotion}`);
            button.textContent = "録音中..."; // ボタンの文字を「録音中...」に変える
            button.disabled = true; // ボタンを一時的に押せなくする
            try {
                // PCに「マイクを使わせて！」とお願いする
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // マイクの音を録音するための「録音機」を準備する
                const rec = new MediaRecorder(stream);
                const chunks = []; // 録音した音声の断片を入れておく配列
                rec.ondataavailable = e => chunks.push(e.data); // 音声データができたら配列に入れる
                
                // 録音が止まったら実行される処理
                rec.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    const formData = new FormData();
                    formData.append('audio', blob);
                    // 録音した声を、感情のラベル（'joy'など）と一緒にサーバーに送る
                    const response = await fetch(`/calibrate?emotion=${emotion}`, { method: 'POST', body: formData });
                    const result = await response.json(); // サーバーからの返事を受け取る
                    if (result.status === 'success') {
                        alert(`「${emotion}」の調整完了！`);
                        calibratedEmotions.add(emotion); // 完了したことを覚えておく
                        button.classList.add('cal-done'); // ボタンの見た目を「完了」に変える
                        button.textContent = `「${emotion}」登録完了`;
                    } else { 
                        alert(`エラー: ${result.error}`); // エラーがあれば表示
                        button.textContent = `「${emotion}」を録音`;
                        button.disabled = false;
                    }
                    stream.getTracks().forEach(track => track.stop()); // マイクを解放する
                };
                
                rec.start(); // 録音開始！
                // 5秒たったら自動で録音を止めるためのタイマー
                setTimeout(() => { if(rec.state === 'recording') rec.stop() }, 5000);
            } catch (err) {
                alert(`マイクエラー: ${err}`);
                button.textContent = `「${emotion}」を録音`;
                button.disabled = false;
            }
        }
        
        // 「分析開始」ボタンが押されたときに動く関数
        async function startAnalysis() {
            if (mediaStream) return; // すでに開始していたら何もしない
            // 議事録などの表示をリセットする
            fullTranscript = "";
            document.getElementById('minutes-log').textContent = "";
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('correctButton').style.display = 'none';
            try {
                // マイクの使用許可をもらい、監視を開始する
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
                visualizeAudio(); // ★音量監視をスタートさせる
            } catch (err) {
                document.getElementById('status').textContent = `エラー: マイクへのアクセスに失敗しました: ${err.message}`;
            }
        }

        // 「分析終了」ボタンが押されたときに動く関数
        async function stopAnalysis() {
            // いろいろなものを停止・リセットして、アプリを開始前の状態に戻す
            if (isRecording) mediaRecorder.stop();
            if (fullTranscript.length > 0) {
                document.getElementById('downloadButton').style.display = 'inline-block';
                document.getElementById('correctButton').style.display = 'inline-block';
            }
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (visualizerFrameId) cancelAnimationFrame(visualizerFrameId);
            if (audioContext && audioContext.state !== 'closed') await audioContext.close();
            mediaStream = audioContext = analyser = visualizerFrameId = silenceTimer = null;
            isRecording = false;
            const volumeBar = document.getElementById('volume-bar');
            volumeBar.style.width = '0%';
            volumeBar.textContent = ''; // 音量の数字を消す
            // すべてのスコアメーターを中立状態に戻す
            const neutralColor = '#CBD5E0', neutralWidth = '50%';
            ['text-score-bar', 'tone-score-bar', 'final-score-bar'].forEach(id => {
                const bar = document.getElementById(id);
                bar.style.width = neutralWidth;
                bar.style.backgroundColor = neutralColor;
                bar.textContent = "0.00";
            });
            document.getElementById('status').textContent = 'マイクの状態: OFF';
        }

        // マイクの音量を監視し続ける、システムの「耳」
        function visualizeAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(mediaStream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const volumeBar = document.getElementById('volume-bar');
            
            // 目で追えない速さで、何度も何度もこの処理を繰り返す
            function draw() {
                visualizerFrameId = requestAnimationFrame(draw);
                if (!analyser) return;
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                const average = sum / bufferLength; // 現在の平均的な音量を計算
                
                // 計算した音量に合わせて、メーターの見た目を変える
                volumeBar.style.width = (average / 128) * 100 + '%';
                // 計算した音量を、数字としてバーの中に書き込む
                volumeBar.textContent = Math.round(average);

                // ★★★ ここがVAD（声の検知）の心臓部 ★★★
                if (average > SPEAKING_THRESHOLD) { // もし声が設定した大きさより大きかったら
                    if (!isRecording) startRecording(); // 「話し始めた！」と判断して録音開始
                    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; } // 沈黙タイマーをリセット
                } else { // もし声が小さかったら
                    if (isRecording && !silenceTimer) { // 話し終わった直後なら
                        // 「黙ったかな？」と判断して、0.75秒の沈黙タイマーを開始
                        silenceTimer = setTimeout(() => stopRecordingAndSend(), SILENCE_DELAY);
                    }
                }
            }
            draw();
        }

        // VADの判断に従って、録音機をスタートさせる関数
        function startRecording() {
            if (!mediaStream) return;
            isRecording = true;
            document.getElementById('status').textContent = 'マイクの状態: 録音中...';
            recordingStartTime = Date.now();
            mediaRecorder = new MediaRecorder(mediaStream);
            mediaRecorder.start();
            const audioChunks = [];
            mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
            mediaRecorder.onstop = () => { if (audioChunks.length > 0) sendToServer(new Blob(audioChunks, { type: 'audio/webm' })); };
        }

        // VADの判断に従って、録音機をストップさせる関数
        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const elapsedTime = Date.now() - recordingStartTime;
                const timeToWait = MIN_RECORDING_TIME - elapsedTime;
                // もし録音時間が短すぎたら、少し待ってから止める
                if (timeToWait > 0) { setTimeout(() => { mediaRecorder.stop(); }, timeToWait); } 
                else { mediaRecorder.stop(); }
                isRecording = false;
                document.getElementById('status').textContent = 'マイクの状態: ON (発言を待っています)';
            }
        }
        
        // 録音した音声データを、サーバーの分析工場に送るトラックの役割
        async function sendToServer(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'realtime_audio.webm');
            formData.append('prompt', document.getElementById('meeting-prompt').value);
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '分析中...';
            try {
                // 実際にサーバーにデータを送信している部分
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json(); // サーバーからの分析結果を受け取る
                if (data.error) { resultDiv.textContent = `エラー: ${data.error}`; return; }
                
                // --- 受け取った結果を画面に反映させる ---
                resultDiv.textContent = data.filtered_text.trim() ? `「${data.filtered_text}」` : '（ハルシネーションとして結果を切り捨てます）';
                // 3つのスコアメーターの見た目を更新する
                updateScoreBar(document.getElementById('text-score-bar'), parseFloat(data.text_score));
                updateScoreBar(document.getElementById('tone-score-bar'), parseFloat(data.tone_score));
                updateScoreBar(document.getElementById('final-score-bar'), parseFloat(data.final_score));
                // 議事録に記録する
                if (data.filtered_text && data.filtered_text.trim().length > 0) {
                    const timestamp = new Date().toLocaleTimeString('ja-JP');
                    const logEntry = `[${timestamp}] ${data.filtered_text} (Final Score: ${data.final_score})\n`;
                    fullTranscript += logEntry;
                    document.getElementById('minutes-log').textContent = fullTranscript;
                    document.getElementById('minutes-log').scrollTop = document.getElementById('minutes-log').scrollHeight; // 自動スクロール
                }
                
                // もしネガティブな判定だったら、猫の画像を表示する
                document.getElementById('catImage').style.display = data.is_negative ? 'block' : 'none';

            } catch (err) { resultDiv.textContent = `通信エラー: ${err}`; }
        }

        // 点数に応じて、メーターの色や長さを変える専門の職人
        function updateScoreBar(barElement, score) {
            const widthPercent = (score + 1) / 2 * 100; // -1.0〜+1.0 のスコアを 0%〜100% の幅に変換
            barElement.style.width = `${widthPercent}%`;
            barElement.textContent = `${(score).toFixed(2)}`; // スコアの数値を表示
            // スコアのプラス・マイナスに応じて色を変える
            if (score < -0.3) { barElement.style.backgroundColor = '#F56565'; } // 赤
            else if (score > 0.3) { barElement.style.backgroundColor = '#48BB78'; } // 緑
            else { barElement.style.backgroundColor = '#4299E1'; } // 青 (中立)
        }

        // 議事録の校正ボタンが押されたときに動く関数
        async function correctWithLLM() {
            const minutesLog = document.getElementById('minutes-log');
            const originalText = fullTranscript;
            minutesLog.textContent = "LLM(大規模言語モデル)が校正中です...しばらくお待ちください...";
            try {
                const response = await fetch('/correct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: originalText })
                });
                const data = await response.json();
                if (data.error) {
                    minutesLog.textContent = `LLMエラー: ${data.error}`;
                } else {
                    minutesLog.textContent = data.corrected_text;
                    fullTranscript = data.corrected_text; 
                }
            } catch (err) {
                minutesLog.textContent = `通信エラー: ${err}`;
            }
        }

        // 議事録のダウンロードボタンが押されたときに動く関数
        function downloadMinutes() {
            let meetingTitle = document.getElementById('meeting-prompt').value.split(' ')[0] || "議事録";
            const blob = new Blob([fullTranscript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
a.href = url;
            a.download = `${meetingTitle}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>